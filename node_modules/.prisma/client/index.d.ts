
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Assistant
 * 
 */
export type Assistant = $Result.DefaultSelection<Prisma.$AssistantPayload>
/**
 * Model TelegramBot
 * 
 */
export type TelegramBot = $Result.DefaultSelection<Prisma.$TelegramBotPayload>
/**
 * Model TelegramUserBot
 * 
 */
export type TelegramUserBot = $Result.DefaultSelection<Prisma.$TelegramUserBotPayload>
/**
 * Model WhatsAppBot
 * 
 */
export type WhatsAppBot = $Result.DefaultSelection<Prisma.$WhatsAppBotPayload>
/**
 * Model JivoBot
 * 
 */
export type JivoBot = $Result.DefaultSelection<Prisma.$JivoBotPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Profiles
 * const profiles = await prisma.profile.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Profiles
   * const profiles = await prisma.profile.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.assistant`: Exposes CRUD operations for the **Assistant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assistants
    * const assistants = await prisma.assistant.findMany()
    * ```
    */
  get assistant(): Prisma.AssistantDelegate<ExtArgs>;

  /**
   * `prisma.telegramBot`: Exposes CRUD operations for the **TelegramBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramBots
    * const telegramBots = await prisma.telegramBot.findMany()
    * ```
    */
  get telegramBot(): Prisma.TelegramBotDelegate<ExtArgs>;

  /**
   * `prisma.telegramUserBot`: Exposes CRUD operations for the **TelegramUserBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramUserBots
    * const telegramUserBots = await prisma.telegramUserBot.findMany()
    * ```
    */
  get telegramUserBot(): Prisma.TelegramUserBotDelegate<ExtArgs>;

  /**
   * `prisma.whatsAppBot`: Exposes CRUD operations for the **WhatsAppBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppBots
    * const whatsAppBots = await prisma.whatsAppBot.findMany()
    * ```
    */
  get whatsAppBot(): Prisma.WhatsAppBotDelegate<ExtArgs>;

  /**
   * `prisma.jivoBot`: Exposes CRUD operations for the **JivoBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JivoBots
    * const jivoBots = await prisma.jivoBot.findMany()
    * ```
    */
  get jivoBot(): Prisma.JivoBotDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.4.0
   * Query Engine version: a5596b96668f0f4b397761ce0956db54e17e48c4
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Profile: 'Profile',
    Assistant: 'Assistant',
    TelegramBot: 'TelegramBot',
    TelegramUserBot: 'TelegramUserBot',
    WhatsAppBot: 'WhatsAppBot',
    JivoBot: 'JivoBot'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'profile' | 'assistant' | 'telegramBot' | 'telegramUserBot' | 'whatsAppBot' | 'jivoBot'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Assistant: {
        payload: Prisma.$AssistantPayload<ExtArgs>
        fields: Prisma.AssistantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssistantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssistantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          findFirst: {
            args: Prisma.AssistantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssistantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          findMany: {
            args: Prisma.AssistantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>[]
          }
          create: {
            args: Prisma.AssistantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          createMany: {
            args: Prisma.AssistantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AssistantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          update: {
            args: Prisma.AssistantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          deleteMany: {
            args: Prisma.AssistantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssistantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssistantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          aggregate: {
            args: Prisma.AssistantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssistant>
          }
          groupBy: {
            args: Prisma.AssistantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssistantGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssistantCountArgs<ExtArgs>,
            result: $Utils.Optional<AssistantCountAggregateOutputType> | number
          }
        }
      }
      TelegramBot: {
        payload: Prisma.$TelegramBotPayload<ExtArgs>
        fields: Prisma.TelegramBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramBotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramBotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>
          }
          findFirst: {
            args: Prisma.TelegramBotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramBotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>
          }
          findMany: {
            args: Prisma.TelegramBotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>[]
          }
          create: {
            args: Prisma.TelegramBotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>
          }
          createMany: {
            args: Prisma.TelegramBotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TelegramBotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>
          }
          update: {
            args: Prisma.TelegramBotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>
          }
          deleteMany: {
            args: Prisma.TelegramBotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramBotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TelegramBotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramBotPayload>
          }
          aggregate: {
            args: Prisma.TelegramBotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTelegramBot>
          }
          groupBy: {
            args: Prisma.TelegramBotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TelegramBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramBotCountArgs<ExtArgs>,
            result: $Utils.Optional<TelegramBotCountAggregateOutputType> | number
          }
        }
      }
      TelegramUserBot: {
        payload: Prisma.$TelegramUserBotPayload<ExtArgs>
        fields: Prisma.TelegramUserBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramUserBotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramUserBotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>
          }
          findFirst: {
            args: Prisma.TelegramUserBotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramUserBotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>
          }
          findMany: {
            args: Prisma.TelegramUserBotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>[]
          }
          create: {
            args: Prisma.TelegramUserBotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>
          }
          createMany: {
            args: Prisma.TelegramUserBotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TelegramUserBotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>
          }
          update: {
            args: Prisma.TelegramUserBotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>
          }
          deleteMany: {
            args: Prisma.TelegramUserBotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramUserBotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TelegramUserBotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TelegramUserBotPayload>
          }
          aggregate: {
            args: Prisma.TelegramUserBotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTelegramUserBot>
          }
          groupBy: {
            args: Prisma.TelegramUserBotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TelegramUserBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramUserBotCountArgs<ExtArgs>,
            result: $Utils.Optional<TelegramUserBotCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppBot: {
        payload: Prisma.$WhatsAppBotPayload<ExtArgs>
        fields: Prisma.WhatsAppBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppBotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppBotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppBotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppBotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>
          }
          findMany: {
            args: Prisma.WhatsAppBotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>[]
          }
          create: {
            args: Prisma.WhatsAppBotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>
          }
          createMany: {
            args: Prisma.WhatsAppBotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WhatsAppBotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>
          }
          update: {
            args: Prisma.WhatsAppBotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppBotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppBotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WhatsAppBotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBotPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppBotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWhatsAppBot>
          }
          groupBy: {
            args: Prisma.WhatsAppBotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WhatsAppBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppBotCountArgs<ExtArgs>,
            result: $Utils.Optional<WhatsAppBotCountAggregateOutputType> | number
          }
        }
      }
      JivoBot: {
        payload: Prisma.$JivoBotPayload<ExtArgs>
        fields: Prisma.JivoBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JivoBotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JivoBotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>
          }
          findFirst: {
            args: Prisma.JivoBotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JivoBotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>
          }
          findMany: {
            args: Prisma.JivoBotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>[]
          }
          create: {
            args: Prisma.JivoBotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>
          }
          createMany: {
            args: Prisma.JivoBotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JivoBotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>
          }
          update: {
            args: Prisma.JivoBotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>
          }
          deleteMany: {
            args: Prisma.JivoBotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JivoBotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JivoBotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JivoBotPayload>
          }
          aggregate: {
            args: Prisma.JivoBotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJivoBot>
          }
          groupBy: {
            args: Prisma.JivoBotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JivoBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.JivoBotCountArgs<ExtArgs>,
            result: $Utils.Optional<JivoBotCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    assistants: number
    telegramBots: number
    telegramUserBots: number
    whatsAppBot: number
    JivoBot: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | ProfileCountOutputTypeCountAssistantsArgs
    telegramBots?: boolean | ProfileCountOutputTypeCountTelegramBotsArgs
    telegramUserBots?: boolean | ProfileCountOutputTypeCountTelegramUserBotsArgs
    whatsAppBot?: boolean | ProfileCountOutputTypeCountWhatsAppBotArgs
    JivoBot?: boolean | ProfileCountOutputTypeCountJivoBotArgs
  }

  // Custom InputTypes

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssistantWhereInput
  }


  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTelegramBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramBotWhereInput
  }


  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTelegramUserBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramUserBotWhereInput
  }


  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountWhatsAppBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBotWhereInput
  }


  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountJivoBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JivoBotWhereInput
  }



  /**
   * Count Type AssistantCountOutputType
   */

  export type AssistantCountOutputType = {
    telegramBots: number
    telegramUserBots: number
    whatsAppBot: number
    jivoBot: number
  }

  export type AssistantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    telegramBots?: boolean | AssistantCountOutputTypeCountTelegramBotsArgs
    telegramUserBots?: boolean | AssistantCountOutputTypeCountTelegramUserBotsArgs
    whatsAppBot?: boolean | AssistantCountOutputTypeCountWhatsAppBotArgs
    jivoBot?: boolean | AssistantCountOutputTypeCountJivoBotArgs
  }

  // Custom InputTypes

  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssistantCountOutputType
     */
    select?: AssistantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeCountTelegramBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramBotWhereInput
  }


  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeCountTelegramUserBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramUserBotWhereInput
  }


  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeCountWhatsAppBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBotWhereInput
  }


  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeCountJivoBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JivoBotWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    imageUrl: string | null
    login: string | null
    password: string | null
    email: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expires: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    imageUrl: string | null
    login: string | null
    password: string | null
    email: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expires: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    imageUrl: number
    login: number
    password: number
    email: number
    token: number
    createdAt: number
    updatedAt: number
    expires: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    imageUrl?: true
    login?: true
    password?: true
    email?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    expires?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    imageUrl?: true
    login?: true
    password?: true
    email?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    expires?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    imageUrl?: true
    login?: true
    password?: true
    email?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    expires?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    name: string
    imageUrl: string
    login: string | null
    password: string | null
    email: string | null
    token: string
    createdAt: Date
    updatedAt: Date
    expires: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    imageUrl?: boolean
    login?: boolean
    password?: boolean
    email?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expires?: boolean
    assistants?: boolean | Profile$assistantsArgs<ExtArgs>
    telegramBots?: boolean | Profile$telegramBotsArgs<ExtArgs>
    telegramUserBots?: boolean | Profile$telegramUserBotsArgs<ExtArgs>
    whatsAppBot?: boolean | Profile$whatsAppBotArgs<ExtArgs>
    JivoBot?: boolean | Profile$JivoBotArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    imageUrl?: boolean
    login?: boolean
    password?: boolean
    email?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expires?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | Profile$assistantsArgs<ExtArgs>
    telegramBots?: boolean | Profile$telegramBotsArgs<ExtArgs>
    telegramUserBots?: boolean | Profile$telegramUserBotsArgs<ExtArgs>
    whatsAppBot?: boolean | Profile$whatsAppBotArgs<ExtArgs>
    JivoBot?: boolean | Profile$JivoBotArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      assistants: Prisma.$AssistantPayload<ExtArgs>[]
      telegramBots: Prisma.$TelegramBotPayload<ExtArgs>[]
      telegramUserBots: Prisma.$TelegramUserBotPayload<ExtArgs>[]
      whatsAppBot: Prisma.$WhatsAppBotPayload<ExtArgs>[]
      JivoBot: Prisma.$JivoBotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      imageUrl: string
      login: string | null
      password: string | null
      email: string | null
      token: string
      createdAt: Date
      updatedAt: Date
      expires: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }


  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    assistants<T extends Profile$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findMany'> | Null>;

    telegramBots<T extends Profile$telegramBotsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$telegramBotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    telegramUserBots<T extends Profile$telegramUserBotsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$telegramUserBotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    whatsAppBot<T extends Profile$whatsAppBotArgs<ExtArgs> = {}>(args?: Subset<T, Profile$whatsAppBotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    JivoBot<T extends Profile$JivoBotArgs<ExtArgs> = {}>(args?: Subset<T, Profile$JivoBotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly name: FieldRef<"Profile", 'String'>
    readonly imageUrl: FieldRef<"Profile", 'String'>
    readonly login: FieldRef<"Profile", 'String'>
    readonly password: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly token: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly expires: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile.assistants
   */
  export type Profile$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    where?: AssistantWhereInput
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    cursor?: AssistantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }


  /**
   * Profile.telegramBots
   */
  export type Profile$telegramBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    where?: TelegramBotWhereInput
    orderBy?: TelegramBotOrderByWithRelationInput | TelegramBotOrderByWithRelationInput[]
    cursor?: TelegramBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramBotScalarFieldEnum | TelegramBotScalarFieldEnum[]
  }


  /**
   * Profile.telegramUserBots
   */
  export type Profile$telegramUserBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    where?: TelegramUserBotWhereInput
    orderBy?: TelegramUserBotOrderByWithRelationInput | TelegramUserBotOrderByWithRelationInput[]
    cursor?: TelegramUserBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramUserBotScalarFieldEnum | TelegramUserBotScalarFieldEnum[]
  }


  /**
   * Profile.whatsAppBot
   */
  export type Profile$whatsAppBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    where?: WhatsAppBotWhereInput
    orderBy?: WhatsAppBotOrderByWithRelationInput | WhatsAppBotOrderByWithRelationInput[]
    cursor?: WhatsAppBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppBotScalarFieldEnum | WhatsAppBotScalarFieldEnum[]
  }


  /**
   * Profile.JivoBot
   */
  export type Profile$JivoBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    where?: JivoBotWhereInput
    orderBy?: JivoBotOrderByWithRelationInput | JivoBotOrderByWithRelationInput[]
    cursor?: JivoBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JivoBotScalarFieldEnum | JivoBotScalarFieldEnum[]
  }


  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
  }



  /**
   * Model Assistant
   */

  export type AggregateAssistant = {
    _count: AssistantCountAggregateOutputType | null
    _avg: AssistantAvgAggregateOutputType | null
    _sum: AssistantSumAggregateOutputType | null
    _min: AssistantMinAggregateOutputType | null
    _max: AssistantMaxAggregateOutputType | null
  }

  export type AssistantAvgAggregateOutputType = {
    use_count: number | null
    temperature: number | null
  }

  export type AssistantSumAggregateOutputType = {
    use_count: number | null
    temperature: number | null
  }

  export type AssistantMinAggregateOutputType = {
    id: string | null
    name: string | null
    settings: string | null
    use_count: number | null
    comment: string | null
    token: string | null
    imageUrl: string | null
    temperature: number | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssistantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    settings: string | null
    use_count: number | null
    comment: string | null
    token: string | null
    imageUrl: string | null
    temperature: number | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssistantCountAggregateOutputType = {
    id: number
    name: number
    settings: number
    use_count: number
    comment: number
    token: number
    imageUrl: number
    temperature: number
    profileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssistantAvgAggregateInputType = {
    use_count?: true
    temperature?: true
  }

  export type AssistantSumAggregateInputType = {
    use_count?: true
    temperature?: true
  }

  export type AssistantMinAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    use_count?: true
    comment?: true
    token?: true
    imageUrl?: true
    temperature?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssistantMaxAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    use_count?: true
    comment?: true
    token?: true
    imageUrl?: true
    temperature?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssistantCountAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    use_count?: true
    comment?: true
    token?: true
    imageUrl?: true
    temperature?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssistantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assistant to aggregate.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assistants
    **/
    _count?: true | AssistantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssistantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssistantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssistantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssistantMaxAggregateInputType
  }

  export type GetAssistantAggregateType<T extends AssistantAggregateArgs> = {
        [P in keyof T & keyof AggregateAssistant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssistant[P]>
      : GetScalarType<T[P], AggregateAssistant[P]>
  }




  export type AssistantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssistantWhereInput
    orderBy?: AssistantOrderByWithAggregationInput | AssistantOrderByWithAggregationInput[]
    by: AssistantScalarFieldEnum[] | AssistantScalarFieldEnum
    having?: AssistantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssistantCountAggregateInputType | true
    _avg?: AssistantAvgAggregateInputType
    _sum?: AssistantSumAggregateInputType
    _min?: AssistantMinAggregateInputType
    _max?: AssistantMaxAggregateInputType
  }

  export type AssistantGroupByOutputType = {
    id: string
    name: string
    settings: string
    use_count: number
    comment: string
    token: string
    imageUrl: string
    temperature: number
    profileId: string
    createdAt: Date
    updatedAt: Date
    _count: AssistantCountAggregateOutputType | null
    _avg: AssistantAvgAggregateOutputType | null
    _sum: AssistantSumAggregateOutputType | null
    _min: AssistantMinAggregateOutputType | null
    _max: AssistantMaxAggregateOutputType | null
  }

  type GetAssistantGroupByPayload<T extends AssistantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssistantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssistantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssistantGroupByOutputType[P]>
            : GetScalarType<T[P], AssistantGroupByOutputType[P]>
        }
      >
    >


  export type AssistantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    settings?: boolean
    use_count?: boolean
    comment?: boolean
    token?: boolean
    imageUrl?: boolean
    temperature?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    telegramBots?: boolean | Assistant$telegramBotsArgs<ExtArgs>
    telegramUserBots?: boolean | Assistant$telegramUserBotsArgs<ExtArgs>
    whatsAppBot?: boolean | Assistant$whatsAppBotArgs<ExtArgs>
    jivoBot?: boolean | Assistant$jivoBotArgs<ExtArgs>
    _count?: boolean | AssistantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistant"]>

  export type AssistantSelectScalar = {
    id?: boolean
    name?: boolean
    settings?: boolean
    use_count?: boolean
    comment?: boolean
    token?: boolean
    imageUrl?: boolean
    temperature?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssistantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    telegramBots?: boolean | Assistant$telegramBotsArgs<ExtArgs>
    telegramUserBots?: boolean | Assistant$telegramUserBotsArgs<ExtArgs>
    whatsAppBot?: boolean | Assistant$whatsAppBotArgs<ExtArgs>
    jivoBot?: boolean | Assistant$jivoBotArgs<ExtArgs>
    _count?: boolean | AssistantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AssistantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assistant"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      telegramBots: Prisma.$TelegramBotPayload<ExtArgs>[]
      telegramUserBots: Prisma.$TelegramUserBotPayload<ExtArgs>[]
      whatsAppBot: Prisma.$WhatsAppBotPayload<ExtArgs>[]
      jivoBot: Prisma.$JivoBotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      settings: string
      use_count: number
      comment: string
      token: string
      imageUrl: string
      temperature: number
      profileId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assistant"]>
    composites: {}
  }


  type AssistantGetPayload<S extends boolean | null | undefined | AssistantDefaultArgs> = $Result.GetResult<Prisma.$AssistantPayload, S>

  type AssistantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssistantFindManyArgs, 'select' | 'include'> & {
      select?: AssistantCountAggregateInputType | true
    }

  export interface AssistantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assistant'], meta: { name: 'Assistant' } }
    /**
     * Find zero or one Assistant that matches the filter.
     * @param {AssistantFindUniqueArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssistantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssistantFindUniqueArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Assistant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AssistantFindUniqueOrThrowArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssistantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssistantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Assistant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantFindFirstArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssistantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssistantFindFirstArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Assistant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantFindFirstOrThrowArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssistantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssistantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assistants
     * const assistants = await prisma.assistant.findMany()
     * 
     * // Get first 10 Assistants
     * const assistants = await prisma.assistant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assistantWithIdOnly = await prisma.assistant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssistantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssistantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Assistant.
     * @param {AssistantCreateArgs} args - Arguments to create a Assistant.
     * @example
     * // Create one Assistant
     * const Assistant = await prisma.assistant.create({
     *   data: {
     *     // ... data to create a Assistant
     *   }
     * })
     * 
    **/
    create<T extends AssistantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssistantCreateArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assistants.
     *     @param {AssistantCreateManyArgs} args - Arguments to create many Assistants.
     *     @example
     *     // Create many Assistants
     *     const assistant = await prisma.assistant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AssistantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssistantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assistant.
     * @param {AssistantDeleteArgs} args - Arguments to delete one Assistant.
     * @example
     * // Delete one Assistant
     * const Assistant = await prisma.assistant.delete({
     *   where: {
     *     // ... filter to delete one Assistant
     *   }
     * })
     * 
    **/
    delete<T extends AssistantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssistantDeleteArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Assistant.
     * @param {AssistantUpdateArgs} args - Arguments to update one Assistant.
     * @example
     * // Update one Assistant
     * const assistant = await prisma.assistant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssistantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssistantUpdateArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assistants.
     * @param {AssistantDeleteManyArgs} args - Arguments to filter Assistants to delete.
     * @example
     * // Delete a few Assistants
     * const { count } = await prisma.assistant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssistantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssistantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assistants
     * const assistant = await prisma.assistant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssistantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssistantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assistant.
     * @param {AssistantUpsertArgs} args - Arguments to update or create a Assistant.
     * @example
     * // Update or create a Assistant
     * const assistant = await prisma.assistant.upsert({
     *   create: {
     *     // ... data to create a Assistant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assistant we want to update
     *   }
     * })
    **/
    upsert<T extends AssistantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssistantUpsertArgs<ExtArgs>>
    ): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantCountArgs} args - Arguments to filter Assistants to count.
     * @example
     * // Count the number of Assistants
     * const count = await prisma.assistant.count({
     *   where: {
     *     // ... the filter for the Assistants we want to count
     *   }
     * })
    **/
    count<T extends AssistantCountArgs>(
      args?: Subset<T, AssistantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssistantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssistantAggregateArgs>(args: Subset<T, AssistantAggregateArgs>): Prisma.PrismaPromise<GetAssistantAggregateType<T>>

    /**
     * Group by Assistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssistantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssistantGroupByArgs['orderBy'] }
        : { orderBy?: AssistantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssistantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssistantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assistant model
   */
  readonly fields: AssistantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assistant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssistantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    telegramBots<T extends Assistant$telegramBotsArgs<ExtArgs> = {}>(args?: Subset<T, Assistant$telegramBotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    telegramUserBots<T extends Assistant$telegramUserBotsArgs<ExtArgs> = {}>(args?: Subset<T, Assistant$telegramUserBotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    whatsAppBot<T extends Assistant$whatsAppBotArgs<ExtArgs> = {}>(args?: Subset<T, Assistant$whatsAppBotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    jivoBot<T extends Assistant$jivoBotArgs<ExtArgs> = {}>(args?: Subset<T, Assistant$jivoBotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Assistant model
   */ 
  interface AssistantFieldRefs {
    readonly id: FieldRef<"Assistant", 'String'>
    readonly name: FieldRef<"Assistant", 'String'>
    readonly settings: FieldRef<"Assistant", 'String'>
    readonly use_count: FieldRef<"Assistant", 'Int'>
    readonly comment: FieldRef<"Assistant", 'String'>
    readonly token: FieldRef<"Assistant", 'String'>
    readonly imageUrl: FieldRef<"Assistant", 'String'>
    readonly temperature: FieldRef<"Assistant", 'Float'>
    readonly profileId: FieldRef<"Assistant", 'String'>
    readonly createdAt: FieldRef<"Assistant", 'DateTime'>
    readonly updatedAt: FieldRef<"Assistant", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Assistant findUnique
   */
  export type AssistantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where: AssistantWhereUniqueInput
  }


  /**
   * Assistant findUniqueOrThrow
   */
  export type AssistantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where: AssistantWhereUniqueInput
  }


  /**
   * Assistant findFirst
   */
  export type AssistantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assistants.
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assistants.
     */
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }


  /**
   * Assistant findFirstOrThrow
   */
  export type AssistantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assistants.
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assistants.
     */
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }


  /**
   * Assistant findMany
   */
  export type AssistantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistants to fetch.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assistants.
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }


  /**
   * Assistant create
   */
  export type AssistantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * The data needed to create a Assistant.
     */
    data: XOR<AssistantCreateInput, AssistantUncheckedCreateInput>
  }


  /**
   * Assistant createMany
   */
  export type AssistantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assistants.
     */
    data: AssistantCreateManyInput | AssistantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Assistant update
   */
  export type AssistantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * The data needed to update a Assistant.
     */
    data: XOR<AssistantUpdateInput, AssistantUncheckedUpdateInput>
    /**
     * Choose, which Assistant to update.
     */
    where: AssistantWhereUniqueInput
  }


  /**
   * Assistant updateMany
   */
  export type AssistantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assistants.
     */
    data: XOR<AssistantUpdateManyMutationInput, AssistantUncheckedUpdateManyInput>
    /**
     * Filter which Assistants to update
     */
    where?: AssistantWhereInput
  }


  /**
   * Assistant upsert
   */
  export type AssistantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * The filter to search for the Assistant to update in case it exists.
     */
    where: AssistantWhereUniqueInput
    /**
     * In case the Assistant found by the `where` argument doesn't exist, create a new Assistant with this data.
     */
    create: XOR<AssistantCreateInput, AssistantUncheckedCreateInput>
    /**
     * In case the Assistant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssistantUpdateInput, AssistantUncheckedUpdateInput>
  }


  /**
   * Assistant delete
   */
  export type AssistantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter which Assistant to delete.
     */
    where: AssistantWhereUniqueInput
  }


  /**
   * Assistant deleteMany
   */
  export type AssistantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assistants to delete
     */
    where?: AssistantWhereInput
  }


  /**
   * Assistant.telegramBots
   */
  export type Assistant$telegramBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    where?: TelegramBotWhereInput
    orderBy?: TelegramBotOrderByWithRelationInput | TelegramBotOrderByWithRelationInput[]
    cursor?: TelegramBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramBotScalarFieldEnum | TelegramBotScalarFieldEnum[]
  }


  /**
   * Assistant.telegramUserBots
   */
  export type Assistant$telegramUserBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    where?: TelegramUserBotWhereInput
    orderBy?: TelegramUserBotOrderByWithRelationInput | TelegramUserBotOrderByWithRelationInput[]
    cursor?: TelegramUserBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramUserBotScalarFieldEnum | TelegramUserBotScalarFieldEnum[]
  }


  /**
   * Assistant.whatsAppBot
   */
  export type Assistant$whatsAppBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    where?: WhatsAppBotWhereInput
    orderBy?: WhatsAppBotOrderByWithRelationInput | WhatsAppBotOrderByWithRelationInput[]
    cursor?: WhatsAppBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppBotScalarFieldEnum | WhatsAppBotScalarFieldEnum[]
  }


  /**
   * Assistant.jivoBot
   */
  export type Assistant$jivoBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    where?: JivoBotWhereInput
    orderBy?: JivoBotOrderByWithRelationInput | JivoBotOrderByWithRelationInput[]
    cursor?: JivoBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JivoBotScalarFieldEnum | JivoBotScalarFieldEnum[]
  }


  /**
   * Assistant without action
   */
  export type AssistantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
  }



  /**
   * Model TelegramBot
   */

  export type AggregateTelegramBot = {
    _count: TelegramBotCountAggregateOutputType | null
    _avg: TelegramBotAvgAggregateOutputType | null
    _sum: TelegramBotSumAggregateOutputType | null
    _min: TelegramBotMinAggregateOutputType | null
    _max: TelegramBotMaxAggregateOutputType | null
  }

  export type TelegramBotAvgAggregateOutputType = {
    useCount: number | null
  }

  export type TelegramBotSumAggregateOutputType = {
    useCount: number | null
  }

  export type TelegramBotMinAggregateOutputType = {
    id: string | null
    name: string | null
    telegram_id: string | null
    imageUrl: string | null
    useCount: number | null
    token: string | null
    profileId: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramBotMaxAggregateOutputType = {
    id: string | null
    name: string | null
    telegram_id: string | null
    imageUrl: string | null
    useCount: number | null
    token: string | null
    profileId: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramBotCountAggregateOutputType = {
    id: number
    name: number
    telegram_id: number
    imageUrl: number
    useCount: number
    token: number
    profileId: number
    assistantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramBotAvgAggregateInputType = {
    useCount?: true
  }

  export type TelegramBotSumAggregateInputType = {
    useCount?: true
  }

  export type TelegramBotMinAggregateInputType = {
    id?: true
    name?: true
    telegram_id?: true
    imageUrl?: true
    useCount?: true
    token?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramBotMaxAggregateInputType = {
    id?: true
    name?: true
    telegram_id?: true
    imageUrl?: true
    useCount?: true
    token?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramBotCountAggregateInputType = {
    id?: true
    name?: true
    telegram_id?: true
    imageUrl?: true
    useCount?: true
    token?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramBot to aggregate.
     */
    where?: TelegramBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramBots to fetch.
     */
    orderBy?: TelegramBotOrderByWithRelationInput | TelegramBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramBots
    **/
    _count?: true | TelegramBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelegramBotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelegramBotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramBotMaxAggregateInputType
  }

  export type GetTelegramBotAggregateType<T extends TelegramBotAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramBot[P]>
      : GetScalarType<T[P], AggregateTelegramBot[P]>
  }




  export type TelegramBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramBotWhereInput
    orderBy?: TelegramBotOrderByWithAggregationInput | TelegramBotOrderByWithAggregationInput[]
    by: TelegramBotScalarFieldEnum[] | TelegramBotScalarFieldEnum
    having?: TelegramBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramBotCountAggregateInputType | true
    _avg?: TelegramBotAvgAggregateInputType
    _sum?: TelegramBotSumAggregateInputType
    _min?: TelegramBotMinAggregateInputType
    _max?: TelegramBotMaxAggregateInputType
  }

  export type TelegramBotGroupByOutputType = {
    id: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount: number
    token: string
    profileId: string
    assistantId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TelegramBotCountAggregateOutputType | null
    _avg: TelegramBotAvgAggregateOutputType | null
    _sum: TelegramBotSumAggregateOutputType | null
    _min: TelegramBotMinAggregateOutputType | null
    _max: TelegramBotMaxAggregateOutputType | null
  }

  type GetTelegramBotGroupByPayload<T extends TelegramBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramBotGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramBotGroupByOutputType[P]>
        }
      >
    >


  export type TelegramBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    telegram_id?: boolean
    imageUrl?: boolean
    useCount?: boolean
    token?: boolean
    profileId?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | TelegramBot$assistantArgs<ExtArgs>
  }, ExtArgs["result"]["telegramBot"]>

  export type TelegramBotSelectScalar = {
    id?: boolean
    name?: boolean
    telegram_id?: boolean
    imageUrl?: boolean
    useCount?: boolean
    token?: boolean
    profileId?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | TelegramBot$assistantArgs<ExtArgs>
  }


  export type $TelegramBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramBot"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      assistant: Prisma.$AssistantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      telegram_id: string
      imageUrl: string
      useCount: number
      token: string
      profileId: string
      assistantId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramBot"]>
    composites: {}
  }


  type TelegramBotGetPayload<S extends boolean | null | undefined | TelegramBotDefaultArgs> = $Result.GetResult<Prisma.$TelegramBotPayload, S>

  type TelegramBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TelegramBotFindManyArgs, 'select' | 'include'> & {
      select?: TelegramBotCountAggregateInputType | true
    }

  export interface TelegramBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramBot'], meta: { name: 'TelegramBot' } }
    /**
     * Find zero or one TelegramBot that matches the filter.
     * @param {TelegramBotFindUniqueArgs} args - Arguments to find a TelegramBot
     * @example
     * // Get one TelegramBot
     * const telegramBot = await prisma.telegramBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TelegramBotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramBotFindUniqueArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TelegramBot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TelegramBotFindUniqueOrThrowArgs} args - Arguments to find a TelegramBot
     * @example
     * // Get one TelegramBot
     * const telegramBot = await prisma.telegramBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TelegramBotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramBotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TelegramBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotFindFirstArgs} args - Arguments to find a TelegramBot
     * @example
     * // Get one TelegramBot
     * const telegramBot = await prisma.telegramBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TelegramBotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramBotFindFirstArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TelegramBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotFindFirstOrThrowArgs} args - Arguments to find a TelegramBot
     * @example
     * // Get one TelegramBot
     * const telegramBot = await prisma.telegramBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TelegramBotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramBotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TelegramBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramBots
     * const telegramBots = await prisma.telegramBot.findMany()
     * 
     * // Get first 10 TelegramBots
     * const telegramBots = await prisma.telegramBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramBotWithIdOnly = await prisma.telegramBot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TelegramBotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramBotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TelegramBot.
     * @param {TelegramBotCreateArgs} args - Arguments to create a TelegramBot.
     * @example
     * // Create one TelegramBot
     * const TelegramBot = await prisma.telegramBot.create({
     *   data: {
     *     // ... data to create a TelegramBot
     *   }
     * })
     * 
    **/
    create<T extends TelegramBotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramBotCreateArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TelegramBots.
     *     @param {TelegramBotCreateManyArgs} args - Arguments to create many TelegramBots.
     *     @example
     *     // Create many TelegramBots
     *     const telegramBot = await prisma.telegramBot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TelegramBotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramBotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TelegramBot.
     * @param {TelegramBotDeleteArgs} args - Arguments to delete one TelegramBot.
     * @example
     * // Delete one TelegramBot
     * const TelegramBot = await prisma.telegramBot.delete({
     *   where: {
     *     // ... filter to delete one TelegramBot
     *   }
     * })
     * 
    **/
    delete<T extends TelegramBotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramBotDeleteArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TelegramBot.
     * @param {TelegramBotUpdateArgs} args - Arguments to update one TelegramBot.
     * @example
     * // Update one TelegramBot
     * const telegramBot = await prisma.telegramBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TelegramBotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramBotUpdateArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TelegramBots.
     * @param {TelegramBotDeleteManyArgs} args - Arguments to filter TelegramBots to delete.
     * @example
     * // Delete a few TelegramBots
     * const { count } = await prisma.telegramBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TelegramBotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramBotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramBots
     * const telegramBot = await prisma.telegramBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TelegramBotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramBotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TelegramBot.
     * @param {TelegramBotUpsertArgs} args - Arguments to update or create a TelegramBot.
     * @example
     * // Update or create a TelegramBot
     * const telegramBot = await prisma.telegramBot.upsert({
     *   create: {
     *     // ... data to create a TelegramBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramBot we want to update
     *   }
     * })
    **/
    upsert<T extends TelegramBotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramBotUpsertArgs<ExtArgs>>
    ): Prisma__TelegramBotClient<$Result.GetResult<Prisma.$TelegramBotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TelegramBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotCountArgs} args - Arguments to filter TelegramBots to count.
     * @example
     * // Count the number of TelegramBots
     * const count = await prisma.telegramBot.count({
     *   where: {
     *     // ... the filter for the TelegramBots we want to count
     *   }
     * })
    **/
    count<T extends TelegramBotCountArgs>(
      args?: Subset<T, TelegramBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramBotAggregateArgs>(args: Subset<T, TelegramBotAggregateArgs>): Prisma.PrismaPromise<GetTelegramBotAggregateType<T>>

    /**
     * Group by TelegramBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramBotGroupByArgs['orderBy'] }
        : { orderBy?: TelegramBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramBot model
   */
  readonly fields: TelegramBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assistant<T extends TelegramBot$assistantArgs<ExtArgs> = {}>(args?: Subset<T, TelegramBot$assistantArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TelegramBot model
   */ 
  interface TelegramBotFieldRefs {
    readonly id: FieldRef<"TelegramBot", 'String'>
    readonly name: FieldRef<"TelegramBot", 'String'>
    readonly telegram_id: FieldRef<"TelegramBot", 'String'>
    readonly imageUrl: FieldRef<"TelegramBot", 'String'>
    readonly useCount: FieldRef<"TelegramBot", 'Int'>
    readonly token: FieldRef<"TelegramBot", 'String'>
    readonly profileId: FieldRef<"TelegramBot", 'String'>
    readonly assistantId: FieldRef<"TelegramBot", 'String'>
    readonly createdAt: FieldRef<"TelegramBot", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramBot", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TelegramBot findUnique
   */
  export type TelegramBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramBot to fetch.
     */
    where: TelegramBotWhereUniqueInput
  }


  /**
   * TelegramBot findUniqueOrThrow
   */
  export type TelegramBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramBot to fetch.
     */
    where: TelegramBotWhereUniqueInput
  }


  /**
   * TelegramBot findFirst
   */
  export type TelegramBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramBot to fetch.
     */
    where?: TelegramBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramBots to fetch.
     */
    orderBy?: TelegramBotOrderByWithRelationInput | TelegramBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramBots.
     */
    cursor?: TelegramBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramBots.
     */
    distinct?: TelegramBotScalarFieldEnum | TelegramBotScalarFieldEnum[]
  }


  /**
   * TelegramBot findFirstOrThrow
   */
  export type TelegramBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramBot to fetch.
     */
    where?: TelegramBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramBots to fetch.
     */
    orderBy?: TelegramBotOrderByWithRelationInput | TelegramBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramBots.
     */
    cursor?: TelegramBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramBots.
     */
    distinct?: TelegramBotScalarFieldEnum | TelegramBotScalarFieldEnum[]
  }


  /**
   * TelegramBot findMany
   */
  export type TelegramBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramBots to fetch.
     */
    where?: TelegramBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramBots to fetch.
     */
    orderBy?: TelegramBotOrderByWithRelationInput | TelegramBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramBots.
     */
    cursor?: TelegramBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramBots.
     */
    skip?: number
    distinct?: TelegramBotScalarFieldEnum | TelegramBotScalarFieldEnum[]
  }


  /**
   * TelegramBot create
   */
  export type TelegramBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramBot.
     */
    data: XOR<TelegramBotCreateInput, TelegramBotUncheckedCreateInput>
  }


  /**
   * TelegramBot createMany
   */
  export type TelegramBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramBots.
     */
    data: TelegramBotCreateManyInput | TelegramBotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TelegramBot update
   */
  export type TelegramBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramBot.
     */
    data: XOR<TelegramBotUpdateInput, TelegramBotUncheckedUpdateInput>
    /**
     * Choose, which TelegramBot to update.
     */
    where: TelegramBotWhereUniqueInput
  }


  /**
   * TelegramBot updateMany
   */
  export type TelegramBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramBots.
     */
    data: XOR<TelegramBotUpdateManyMutationInput, TelegramBotUncheckedUpdateManyInput>
    /**
     * Filter which TelegramBots to update
     */
    where?: TelegramBotWhereInput
  }


  /**
   * TelegramBot upsert
   */
  export type TelegramBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramBot to update in case it exists.
     */
    where: TelegramBotWhereUniqueInput
    /**
     * In case the TelegramBot found by the `where` argument doesn't exist, create a new TelegramBot with this data.
     */
    create: XOR<TelegramBotCreateInput, TelegramBotUncheckedCreateInput>
    /**
     * In case the TelegramBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramBotUpdateInput, TelegramBotUncheckedUpdateInput>
  }


  /**
   * TelegramBot delete
   */
  export type TelegramBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
    /**
     * Filter which TelegramBot to delete.
     */
    where: TelegramBotWhereUniqueInput
  }


  /**
   * TelegramBot deleteMany
   */
  export type TelegramBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramBots to delete
     */
    where?: TelegramBotWhereInput
  }


  /**
   * TelegramBot.assistant
   */
  export type TelegramBot$assistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssistantInclude<ExtArgs> | null
    where?: AssistantWhereInput
  }


  /**
   * TelegramBot without action
   */
  export type TelegramBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramBot
     */
    select?: TelegramBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramBotInclude<ExtArgs> | null
  }



  /**
   * Model TelegramUserBot
   */

  export type AggregateTelegramUserBot = {
    _count: TelegramUserBotCountAggregateOutputType | null
    _avg: TelegramUserBotAvgAggregateOutputType | null
    _sum: TelegramUserBotSumAggregateOutputType | null
    _min: TelegramUserBotMinAggregateOutputType | null
    _max: TelegramUserBotMaxAggregateOutputType | null
  }

  export type TelegramUserBotAvgAggregateOutputType = {
    useCount: number | null
  }

  export type TelegramUserBotSumAggregateOutputType = {
    useCount: number | null
  }

  export type TelegramUserBotMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    imageUrl: string | null
    useCount: number | null
    phone: string | null
    api_id: string | null
    api_hash: string | null
    profileId: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramUserBotMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    imageUrl: string | null
    useCount: number | null
    phone: string | null
    api_id: string | null
    api_hash: string | null
    profileId: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramUserBotCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    username: number
    imageUrl: number
    useCount: number
    phone: number
    api_id: number
    api_hash: number
    profileId: number
    assistantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramUserBotAvgAggregateInputType = {
    useCount?: true
  }

  export type TelegramUserBotSumAggregateInputType = {
    useCount?: true
  }

  export type TelegramUserBotMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    imageUrl?: true
    useCount?: true
    phone?: true
    api_id?: true
    api_hash?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramUserBotMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    imageUrl?: true
    useCount?: true
    phone?: true
    api_id?: true
    api_hash?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramUserBotCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    imageUrl?: true
    useCount?: true
    phone?: true
    api_id?: true
    api_hash?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramUserBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramUserBot to aggregate.
     */
    where?: TelegramUserBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUserBots to fetch.
     */
    orderBy?: TelegramUserBotOrderByWithRelationInput | TelegramUserBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramUserBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUserBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUserBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramUserBots
    **/
    _count?: true | TelegramUserBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelegramUserBotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelegramUserBotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramUserBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramUserBotMaxAggregateInputType
  }

  export type GetTelegramUserBotAggregateType<T extends TelegramUserBotAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramUserBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramUserBot[P]>
      : GetScalarType<T[P], AggregateTelegramUserBot[P]>
  }




  export type TelegramUserBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramUserBotWhereInput
    orderBy?: TelegramUserBotOrderByWithAggregationInput | TelegramUserBotOrderByWithAggregationInput[]
    by: TelegramUserBotScalarFieldEnum[] | TelegramUserBotScalarFieldEnum
    having?: TelegramUserBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramUserBotCountAggregateInputType | true
    _avg?: TelegramUserBotAvgAggregateInputType
    _sum?: TelegramUserBotSumAggregateInputType
    _min?: TelegramUserBotMinAggregateInputType
    _max?: TelegramUserBotMaxAggregateInputType
  }

  export type TelegramUserBotGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount: number
    phone: string
    api_id: string
    api_hash: string
    profileId: string
    assistantId: string
    createdAt: Date
    updatedAt: Date
    _count: TelegramUserBotCountAggregateOutputType | null
    _avg: TelegramUserBotAvgAggregateOutputType | null
    _sum: TelegramUserBotSumAggregateOutputType | null
    _min: TelegramUserBotMinAggregateOutputType | null
    _max: TelegramUserBotMaxAggregateOutputType | null
  }

  type GetTelegramUserBotGroupByPayload<T extends TelegramUserBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramUserBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramUserBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramUserBotGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramUserBotGroupByOutputType[P]>
        }
      >
    >


  export type TelegramUserBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    imageUrl?: boolean
    useCount?: boolean
    phone?: boolean
    api_id?: boolean
    api_hash?: boolean
    profileId?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | AssistantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramUserBot"]>

  export type TelegramUserBotSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    imageUrl?: boolean
    useCount?: boolean
    phone?: boolean
    api_id?: boolean
    api_hash?: boolean
    profileId?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramUserBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | AssistantDefaultArgs<ExtArgs>
  }


  export type $TelegramUserBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramUserBot"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      assistant: Prisma.$AssistantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      username: string
      imageUrl: string
      useCount: number
      phone: string
      api_id: string
      api_hash: string
      profileId: string
      assistantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramUserBot"]>
    composites: {}
  }


  type TelegramUserBotGetPayload<S extends boolean | null | undefined | TelegramUserBotDefaultArgs> = $Result.GetResult<Prisma.$TelegramUserBotPayload, S>

  type TelegramUserBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TelegramUserBotFindManyArgs, 'select' | 'include'> & {
      select?: TelegramUserBotCountAggregateInputType | true
    }

  export interface TelegramUserBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramUserBot'], meta: { name: 'TelegramUserBot' } }
    /**
     * Find zero or one TelegramUserBot that matches the filter.
     * @param {TelegramUserBotFindUniqueArgs} args - Arguments to find a TelegramUserBot
     * @example
     * // Get one TelegramUserBot
     * const telegramUserBot = await prisma.telegramUserBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TelegramUserBotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramUserBotFindUniqueArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TelegramUserBot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TelegramUserBotFindUniqueOrThrowArgs} args - Arguments to find a TelegramUserBot
     * @example
     * // Get one TelegramUserBot
     * const telegramUserBot = await prisma.telegramUserBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TelegramUserBotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramUserBotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TelegramUserBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotFindFirstArgs} args - Arguments to find a TelegramUserBot
     * @example
     * // Get one TelegramUserBot
     * const telegramUserBot = await prisma.telegramUserBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TelegramUserBotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramUserBotFindFirstArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TelegramUserBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotFindFirstOrThrowArgs} args - Arguments to find a TelegramUserBot
     * @example
     * // Get one TelegramUserBot
     * const telegramUserBot = await prisma.telegramUserBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TelegramUserBotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramUserBotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TelegramUserBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramUserBots
     * const telegramUserBots = await prisma.telegramUserBot.findMany()
     * 
     * // Get first 10 TelegramUserBots
     * const telegramUserBots = await prisma.telegramUserBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramUserBotWithIdOnly = await prisma.telegramUserBot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TelegramUserBotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramUserBotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TelegramUserBot.
     * @param {TelegramUserBotCreateArgs} args - Arguments to create a TelegramUserBot.
     * @example
     * // Create one TelegramUserBot
     * const TelegramUserBot = await prisma.telegramUserBot.create({
     *   data: {
     *     // ... data to create a TelegramUserBot
     *   }
     * })
     * 
    **/
    create<T extends TelegramUserBotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramUserBotCreateArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TelegramUserBots.
     *     @param {TelegramUserBotCreateManyArgs} args - Arguments to create many TelegramUserBots.
     *     @example
     *     // Create many TelegramUserBots
     *     const telegramUserBot = await prisma.telegramUserBot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TelegramUserBotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramUserBotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TelegramUserBot.
     * @param {TelegramUserBotDeleteArgs} args - Arguments to delete one TelegramUserBot.
     * @example
     * // Delete one TelegramUserBot
     * const TelegramUserBot = await prisma.telegramUserBot.delete({
     *   where: {
     *     // ... filter to delete one TelegramUserBot
     *   }
     * })
     * 
    **/
    delete<T extends TelegramUserBotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramUserBotDeleteArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TelegramUserBot.
     * @param {TelegramUserBotUpdateArgs} args - Arguments to update one TelegramUserBot.
     * @example
     * // Update one TelegramUserBot
     * const telegramUserBot = await prisma.telegramUserBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TelegramUserBotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramUserBotUpdateArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TelegramUserBots.
     * @param {TelegramUserBotDeleteManyArgs} args - Arguments to filter TelegramUserBots to delete.
     * @example
     * // Delete a few TelegramUserBots
     * const { count } = await prisma.telegramUserBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TelegramUserBotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TelegramUserBotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramUserBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramUserBots
     * const telegramUserBot = await prisma.telegramUserBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TelegramUserBotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramUserBotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TelegramUserBot.
     * @param {TelegramUserBotUpsertArgs} args - Arguments to update or create a TelegramUserBot.
     * @example
     * // Update or create a TelegramUserBot
     * const telegramUserBot = await prisma.telegramUserBot.upsert({
     *   create: {
     *     // ... data to create a TelegramUserBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramUserBot we want to update
     *   }
     * })
    **/
    upsert<T extends TelegramUserBotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TelegramUserBotUpsertArgs<ExtArgs>>
    ): Prisma__TelegramUserBotClient<$Result.GetResult<Prisma.$TelegramUserBotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TelegramUserBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotCountArgs} args - Arguments to filter TelegramUserBots to count.
     * @example
     * // Count the number of TelegramUserBots
     * const count = await prisma.telegramUserBot.count({
     *   where: {
     *     // ... the filter for the TelegramUserBots we want to count
     *   }
     * })
    **/
    count<T extends TelegramUserBotCountArgs>(
      args?: Subset<T, TelegramUserBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramUserBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramUserBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramUserBotAggregateArgs>(args: Subset<T, TelegramUserBotAggregateArgs>): Prisma.PrismaPromise<GetTelegramUserBotAggregateType<T>>

    /**
     * Group by TelegramUserBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramUserBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramUserBotGroupByArgs['orderBy'] }
        : { orderBy?: TelegramUserBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramUserBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramUserBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramUserBot model
   */
  readonly fields: TelegramUserBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramUserBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramUserBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assistant<T extends AssistantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssistantDefaultArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TelegramUserBot model
   */ 
  interface TelegramUserBotFieldRefs {
    readonly id: FieldRef<"TelegramUserBot", 'String'>
    readonly firstName: FieldRef<"TelegramUserBot", 'String'>
    readonly lastName: FieldRef<"TelegramUserBot", 'String'>
    readonly username: FieldRef<"TelegramUserBot", 'String'>
    readonly imageUrl: FieldRef<"TelegramUserBot", 'String'>
    readonly useCount: FieldRef<"TelegramUserBot", 'Int'>
    readonly phone: FieldRef<"TelegramUserBot", 'String'>
    readonly api_id: FieldRef<"TelegramUserBot", 'String'>
    readonly api_hash: FieldRef<"TelegramUserBot", 'String'>
    readonly profileId: FieldRef<"TelegramUserBot", 'String'>
    readonly assistantId: FieldRef<"TelegramUserBot", 'String'>
    readonly createdAt: FieldRef<"TelegramUserBot", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramUserBot", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TelegramUserBot findUnique
   */
  export type TelegramUserBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUserBot to fetch.
     */
    where: TelegramUserBotWhereUniqueInput
  }


  /**
   * TelegramUserBot findUniqueOrThrow
   */
  export type TelegramUserBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUserBot to fetch.
     */
    where: TelegramUserBotWhereUniqueInput
  }


  /**
   * TelegramUserBot findFirst
   */
  export type TelegramUserBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUserBot to fetch.
     */
    where?: TelegramUserBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUserBots to fetch.
     */
    orderBy?: TelegramUserBotOrderByWithRelationInput | TelegramUserBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramUserBots.
     */
    cursor?: TelegramUserBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUserBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUserBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramUserBots.
     */
    distinct?: TelegramUserBotScalarFieldEnum | TelegramUserBotScalarFieldEnum[]
  }


  /**
   * TelegramUserBot findFirstOrThrow
   */
  export type TelegramUserBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUserBot to fetch.
     */
    where?: TelegramUserBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUserBots to fetch.
     */
    orderBy?: TelegramUserBotOrderByWithRelationInput | TelegramUserBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramUserBots.
     */
    cursor?: TelegramUserBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUserBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUserBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramUserBots.
     */
    distinct?: TelegramUserBotScalarFieldEnum | TelegramUserBotScalarFieldEnum[]
  }


  /**
   * TelegramUserBot findMany
   */
  export type TelegramUserBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUserBots to fetch.
     */
    where?: TelegramUserBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUserBots to fetch.
     */
    orderBy?: TelegramUserBotOrderByWithRelationInput | TelegramUserBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramUserBots.
     */
    cursor?: TelegramUserBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUserBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUserBots.
     */
    skip?: number
    distinct?: TelegramUserBotScalarFieldEnum | TelegramUserBotScalarFieldEnum[]
  }


  /**
   * TelegramUserBot create
   */
  export type TelegramUserBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramUserBot.
     */
    data: XOR<TelegramUserBotCreateInput, TelegramUserBotUncheckedCreateInput>
  }


  /**
   * TelegramUserBot createMany
   */
  export type TelegramUserBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramUserBots.
     */
    data: TelegramUserBotCreateManyInput | TelegramUserBotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TelegramUserBot update
   */
  export type TelegramUserBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramUserBot.
     */
    data: XOR<TelegramUserBotUpdateInput, TelegramUserBotUncheckedUpdateInput>
    /**
     * Choose, which TelegramUserBot to update.
     */
    where: TelegramUserBotWhereUniqueInput
  }


  /**
   * TelegramUserBot updateMany
   */
  export type TelegramUserBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramUserBots.
     */
    data: XOR<TelegramUserBotUpdateManyMutationInput, TelegramUserBotUncheckedUpdateManyInput>
    /**
     * Filter which TelegramUserBots to update
     */
    where?: TelegramUserBotWhereInput
  }


  /**
   * TelegramUserBot upsert
   */
  export type TelegramUserBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramUserBot to update in case it exists.
     */
    where: TelegramUserBotWhereUniqueInput
    /**
     * In case the TelegramUserBot found by the `where` argument doesn't exist, create a new TelegramUserBot with this data.
     */
    create: XOR<TelegramUserBotCreateInput, TelegramUserBotUncheckedCreateInput>
    /**
     * In case the TelegramUserBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramUserBotUpdateInput, TelegramUserBotUncheckedUpdateInput>
  }


  /**
   * TelegramUserBot delete
   */
  export type TelegramUserBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
    /**
     * Filter which TelegramUserBot to delete.
     */
    where: TelegramUserBotWhereUniqueInput
  }


  /**
   * TelegramUserBot deleteMany
   */
  export type TelegramUserBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramUserBots to delete
     */
    where?: TelegramUserBotWhereInput
  }


  /**
   * TelegramUserBot without action
   */
  export type TelegramUserBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUserBot
     */
    select?: TelegramUserBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TelegramUserBotInclude<ExtArgs> | null
  }



  /**
   * Model WhatsAppBot
   */

  export type AggregateWhatsAppBot = {
    _count: WhatsAppBotCountAggregateOutputType | null
    _avg: WhatsAppBotAvgAggregateOutputType | null
    _sum: WhatsAppBotSumAggregateOutputType | null
    _min: WhatsAppBotMinAggregateOutputType | null
    _max: WhatsAppBotMaxAggregateOutputType | null
  }

  export type WhatsAppBotAvgAggregateOutputType = {
    useCount: number | null
  }

  export type WhatsAppBotSumAggregateOutputType = {
    useCount: number | null
  }

  export type WhatsAppBotMinAggregateOutputType = {
    id: string | null
    name: string | null
    settings: string | null
    imageUrl: string | null
    useCount: number | null
    fullName: string | null
    phone: string | null
    IdInstance: string | null
    ApiTokenInstance: string | null
    profileId: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppBotMaxAggregateOutputType = {
    id: string | null
    name: string | null
    settings: string | null
    imageUrl: string | null
    useCount: number | null
    fullName: string | null
    phone: string | null
    IdInstance: string | null
    ApiTokenInstance: string | null
    profileId: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppBotCountAggregateOutputType = {
    id: number
    name: number
    settings: number
    imageUrl: number
    useCount: number
    fullName: number
    phone: number
    IdInstance: number
    ApiTokenInstance: number
    profileId: number
    assistantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppBotAvgAggregateInputType = {
    useCount?: true
  }

  export type WhatsAppBotSumAggregateInputType = {
    useCount?: true
  }

  export type WhatsAppBotMinAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    imageUrl?: true
    useCount?: true
    fullName?: true
    phone?: true
    IdInstance?: true
    ApiTokenInstance?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppBotMaxAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    imageUrl?: true
    useCount?: true
    fullName?: true
    phone?: true
    IdInstance?: true
    ApiTokenInstance?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppBotCountAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    imageUrl?: true
    useCount?: true
    fullName?: true
    phone?: true
    IdInstance?: true
    ApiTokenInstance?: true
    profileId?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppBot to aggregate.
     */
    where?: WhatsAppBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBots to fetch.
     */
    orderBy?: WhatsAppBotOrderByWithRelationInput | WhatsAppBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppBots
    **/
    _count?: true | WhatsAppBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppBotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppBotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppBotMaxAggregateInputType
  }

  export type GetWhatsAppBotAggregateType<T extends WhatsAppBotAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppBot[P]>
      : GetScalarType<T[P], AggregateWhatsAppBot[P]>
  }




  export type WhatsAppBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBotWhereInput
    orderBy?: WhatsAppBotOrderByWithAggregationInput | WhatsAppBotOrderByWithAggregationInput[]
    by: WhatsAppBotScalarFieldEnum[] | WhatsAppBotScalarFieldEnum
    having?: WhatsAppBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppBotCountAggregateInputType | true
    _avg?: WhatsAppBotAvgAggregateInputType
    _sum?: WhatsAppBotSumAggregateInputType
    _min?: WhatsAppBotMinAggregateInputType
    _max?: WhatsAppBotMaxAggregateInputType
  }

  export type WhatsAppBotGroupByOutputType = {
    id: string
    name: string
    settings: string
    imageUrl: string
    useCount: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    profileId: string
    assistantId: string
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppBotCountAggregateOutputType | null
    _avg: WhatsAppBotAvgAggregateOutputType | null
    _sum: WhatsAppBotSumAggregateOutputType | null
    _min: WhatsAppBotMinAggregateOutputType | null
    _max: WhatsAppBotMaxAggregateOutputType | null
  }

  type GetWhatsAppBotGroupByPayload<T extends WhatsAppBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppBotGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppBotGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    settings?: boolean
    imageUrl?: boolean
    useCount?: boolean
    fullName?: boolean
    phone?: boolean
    IdInstance?: boolean
    ApiTokenInstance?: boolean
    profileId?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | AssistantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBot"]>

  export type WhatsAppBotSelectScalar = {
    id?: boolean
    name?: boolean
    settings?: boolean
    imageUrl?: boolean
    useCount?: boolean
    fullName?: boolean
    phone?: boolean
    IdInstance?: boolean
    ApiTokenInstance?: boolean
    profileId?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | AssistantDefaultArgs<ExtArgs>
  }


  export type $WhatsAppBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppBot"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      assistant: Prisma.$AssistantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      settings: string
      imageUrl: string
      useCount: number
      fullName: string
      phone: string
      IdInstance: string
      ApiTokenInstance: string
      profileId: string
      assistantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppBot"]>
    composites: {}
  }


  type WhatsAppBotGetPayload<S extends boolean | null | undefined | WhatsAppBotDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppBotPayload, S>

  type WhatsAppBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhatsAppBotFindManyArgs, 'select' | 'include'> & {
      select?: WhatsAppBotCountAggregateInputType | true
    }

  export interface WhatsAppBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppBot'], meta: { name: 'WhatsAppBot' } }
    /**
     * Find zero or one WhatsAppBot that matches the filter.
     * @param {WhatsAppBotFindUniqueArgs} args - Arguments to find a WhatsAppBot
     * @example
     * // Get one WhatsAppBot
     * const whatsAppBot = await prisma.whatsAppBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WhatsAppBotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WhatsAppBotFindUniqueArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WhatsAppBot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WhatsAppBotFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppBot
     * @example
     * // Get one WhatsAppBot
     * const whatsAppBot = await prisma.whatsAppBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WhatsAppBotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WhatsAppBotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WhatsAppBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotFindFirstArgs} args - Arguments to find a WhatsAppBot
     * @example
     * // Get one WhatsAppBot
     * const whatsAppBot = await prisma.whatsAppBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WhatsAppBotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WhatsAppBotFindFirstArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WhatsAppBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotFindFirstOrThrowArgs} args - Arguments to find a WhatsAppBot
     * @example
     * // Get one WhatsAppBot
     * const whatsAppBot = await prisma.whatsAppBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WhatsAppBotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WhatsAppBotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WhatsAppBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppBots
     * const whatsAppBots = await prisma.whatsAppBot.findMany()
     * 
     * // Get first 10 WhatsAppBots
     * const whatsAppBots = await prisma.whatsAppBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppBotWithIdOnly = await prisma.whatsAppBot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WhatsAppBotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WhatsAppBotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WhatsAppBot.
     * @param {WhatsAppBotCreateArgs} args - Arguments to create a WhatsAppBot.
     * @example
     * // Create one WhatsAppBot
     * const WhatsAppBot = await prisma.whatsAppBot.create({
     *   data: {
     *     // ... data to create a WhatsAppBot
     *   }
     * })
     * 
    **/
    create<T extends WhatsAppBotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WhatsAppBotCreateArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WhatsAppBots.
     *     @param {WhatsAppBotCreateManyArgs} args - Arguments to create many WhatsAppBots.
     *     @example
     *     // Create many WhatsAppBots
     *     const whatsAppBot = await prisma.whatsAppBot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WhatsAppBotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WhatsAppBotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WhatsAppBot.
     * @param {WhatsAppBotDeleteArgs} args - Arguments to delete one WhatsAppBot.
     * @example
     * // Delete one WhatsAppBot
     * const WhatsAppBot = await prisma.whatsAppBot.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppBot
     *   }
     * })
     * 
    **/
    delete<T extends WhatsAppBotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WhatsAppBotDeleteArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WhatsAppBot.
     * @param {WhatsAppBotUpdateArgs} args - Arguments to update one WhatsAppBot.
     * @example
     * // Update one WhatsAppBot
     * const whatsAppBot = await prisma.whatsAppBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WhatsAppBotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WhatsAppBotUpdateArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WhatsAppBots.
     * @param {WhatsAppBotDeleteManyArgs} args - Arguments to filter WhatsAppBots to delete.
     * @example
     * // Delete a few WhatsAppBots
     * const { count } = await prisma.whatsAppBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WhatsAppBotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WhatsAppBotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppBots
     * const whatsAppBot = await prisma.whatsAppBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WhatsAppBotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WhatsAppBotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhatsAppBot.
     * @param {WhatsAppBotUpsertArgs} args - Arguments to update or create a WhatsAppBot.
     * @example
     * // Update or create a WhatsAppBot
     * const whatsAppBot = await prisma.whatsAppBot.upsert({
     *   create: {
     *     // ... data to create a WhatsAppBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppBot we want to update
     *   }
     * })
    **/
    upsert<T extends WhatsAppBotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WhatsAppBotUpsertArgs<ExtArgs>>
    ): Prisma__WhatsAppBotClient<$Result.GetResult<Prisma.$WhatsAppBotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WhatsAppBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotCountArgs} args - Arguments to filter WhatsAppBots to count.
     * @example
     * // Count the number of WhatsAppBots
     * const count = await prisma.whatsAppBot.count({
     *   where: {
     *     // ... the filter for the WhatsAppBots we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppBotCountArgs>(
      args?: Subset<T, WhatsAppBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppBotAggregateArgs>(args: Subset<T, WhatsAppBotAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppBotAggregateType<T>>

    /**
     * Group by WhatsAppBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppBotGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppBot model
   */
  readonly fields: WhatsAppBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assistant<T extends AssistantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssistantDefaultArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WhatsAppBot model
   */ 
  interface WhatsAppBotFieldRefs {
    readonly id: FieldRef<"WhatsAppBot", 'String'>
    readonly name: FieldRef<"WhatsAppBot", 'String'>
    readonly settings: FieldRef<"WhatsAppBot", 'String'>
    readonly imageUrl: FieldRef<"WhatsAppBot", 'String'>
    readonly useCount: FieldRef<"WhatsAppBot", 'Int'>
    readonly fullName: FieldRef<"WhatsAppBot", 'String'>
    readonly phone: FieldRef<"WhatsAppBot", 'String'>
    readonly IdInstance: FieldRef<"WhatsAppBot", 'String'>
    readonly ApiTokenInstance: FieldRef<"WhatsAppBot", 'String'>
    readonly profileId: FieldRef<"WhatsAppBot", 'String'>
    readonly assistantId: FieldRef<"WhatsAppBot", 'String'>
    readonly createdAt: FieldRef<"WhatsAppBot", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppBot", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * WhatsAppBot findUnique
   */
  export type WhatsAppBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBot to fetch.
     */
    where: WhatsAppBotWhereUniqueInput
  }


  /**
   * WhatsAppBot findUniqueOrThrow
   */
  export type WhatsAppBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBot to fetch.
     */
    where: WhatsAppBotWhereUniqueInput
  }


  /**
   * WhatsAppBot findFirst
   */
  export type WhatsAppBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBot to fetch.
     */
    where?: WhatsAppBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBots to fetch.
     */
    orderBy?: WhatsAppBotOrderByWithRelationInput | WhatsAppBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppBots.
     */
    cursor?: WhatsAppBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppBots.
     */
    distinct?: WhatsAppBotScalarFieldEnum | WhatsAppBotScalarFieldEnum[]
  }


  /**
   * WhatsAppBot findFirstOrThrow
   */
  export type WhatsAppBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBot to fetch.
     */
    where?: WhatsAppBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBots to fetch.
     */
    orderBy?: WhatsAppBotOrderByWithRelationInput | WhatsAppBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppBots.
     */
    cursor?: WhatsAppBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppBots.
     */
    distinct?: WhatsAppBotScalarFieldEnum | WhatsAppBotScalarFieldEnum[]
  }


  /**
   * WhatsAppBot findMany
   */
  export type WhatsAppBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBots to fetch.
     */
    where?: WhatsAppBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBots to fetch.
     */
    orderBy?: WhatsAppBotOrderByWithRelationInput | WhatsAppBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppBots.
     */
    cursor?: WhatsAppBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBots.
     */
    skip?: number
    distinct?: WhatsAppBotScalarFieldEnum | WhatsAppBotScalarFieldEnum[]
  }


  /**
   * WhatsAppBot create
   */
  export type WhatsAppBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppBot.
     */
    data: XOR<WhatsAppBotCreateInput, WhatsAppBotUncheckedCreateInput>
  }


  /**
   * WhatsAppBot createMany
   */
  export type WhatsAppBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppBots.
     */
    data: WhatsAppBotCreateManyInput | WhatsAppBotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WhatsAppBot update
   */
  export type WhatsAppBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppBot.
     */
    data: XOR<WhatsAppBotUpdateInput, WhatsAppBotUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppBot to update.
     */
    where: WhatsAppBotWhereUniqueInput
  }


  /**
   * WhatsAppBot updateMany
   */
  export type WhatsAppBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppBots.
     */
    data: XOR<WhatsAppBotUpdateManyMutationInput, WhatsAppBotUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppBots to update
     */
    where?: WhatsAppBotWhereInput
  }


  /**
   * WhatsAppBot upsert
   */
  export type WhatsAppBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppBot to update in case it exists.
     */
    where: WhatsAppBotWhereUniqueInput
    /**
     * In case the WhatsAppBot found by the `where` argument doesn't exist, create a new WhatsAppBot with this data.
     */
    create: XOR<WhatsAppBotCreateInput, WhatsAppBotUncheckedCreateInput>
    /**
     * In case the WhatsAppBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppBotUpdateInput, WhatsAppBotUncheckedUpdateInput>
  }


  /**
   * WhatsAppBot delete
   */
  export type WhatsAppBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppBot to delete.
     */
    where: WhatsAppBotWhereUniqueInput
  }


  /**
   * WhatsAppBot deleteMany
   */
  export type WhatsAppBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppBots to delete
     */
    where?: WhatsAppBotWhereInput
  }


  /**
   * WhatsAppBot without action
   */
  export type WhatsAppBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBot
     */
    select?: WhatsAppBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhatsAppBotInclude<ExtArgs> | null
  }



  /**
   * Model JivoBot
   */

  export type AggregateJivoBot = {
    _count: JivoBotCountAggregateOutputType | null
    _avg: JivoBotAvgAggregateOutputType | null
    _sum: JivoBotSumAggregateOutputType | null
    _min: JivoBotMinAggregateOutputType | null
    _max: JivoBotMaxAggregateOutputType | null
  }

  export type JivoBotAvgAggregateOutputType = {
    useCount: number | null
  }

  export type JivoBotSumAggregateOutputType = {
    useCount: number | null
  }

  export type JivoBotMinAggregateOutputType = {
    id: string | null
    name: string | null
    settings: string | null
    imageUrl: string | null
    profileId: string | null
    useCount: number | null
    provider_id: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JivoBotMaxAggregateOutputType = {
    id: string | null
    name: string | null
    settings: string | null
    imageUrl: string | null
    profileId: string | null
    useCount: number | null
    provider_id: string | null
    assistantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JivoBotCountAggregateOutputType = {
    id: number
    name: number
    settings: number
    imageUrl: number
    profileId: number
    useCount: number
    provider_id: number
    assistantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JivoBotAvgAggregateInputType = {
    useCount?: true
  }

  export type JivoBotSumAggregateInputType = {
    useCount?: true
  }

  export type JivoBotMinAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    imageUrl?: true
    profileId?: true
    useCount?: true
    provider_id?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JivoBotMaxAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    imageUrl?: true
    profileId?: true
    useCount?: true
    provider_id?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JivoBotCountAggregateInputType = {
    id?: true
    name?: true
    settings?: true
    imageUrl?: true
    profileId?: true
    useCount?: true
    provider_id?: true
    assistantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JivoBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JivoBot to aggregate.
     */
    where?: JivoBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JivoBots to fetch.
     */
    orderBy?: JivoBotOrderByWithRelationInput | JivoBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JivoBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JivoBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JivoBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JivoBots
    **/
    _count?: true | JivoBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JivoBotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JivoBotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JivoBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JivoBotMaxAggregateInputType
  }

  export type GetJivoBotAggregateType<T extends JivoBotAggregateArgs> = {
        [P in keyof T & keyof AggregateJivoBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJivoBot[P]>
      : GetScalarType<T[P], AggregateJivoBot[P]>
  }




  export type JivoBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JivoBotWhereInput
    orderBy?: JivoBotOrderByWithAggregationInput | JivoBotOrderByWithAggregationInput[]
    by: JivoBotScalarFieldEnum[] | JivoBotScalarFieldEnum
    having?: JivoBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JivoBotCountAggregateInputType | true
    _avg?: JivoBotAvgAggregateInputType
    _sum?: JivoBotSumAggregateInputType
    _min?: JivoBotMinAggregateInputType
    _max?: JivoBotMaxAggregateInputType
  }

  export type JivoBotGroupByOutputType = {
    id: string
    name: string
    settings: string
    imageUrl: string
    profileId: string
    useCount: number
    provider_id: string
    assistantId: string
    createdAt: Date
    updatedAt: Date
    _count: JivoBotCountAggregateOutputType | null
    _avg: JivoBotAvgAggregateOutputType | null
    _sum: JivoBotSumAggregateOutputType | null
    _min: JivoBotMinAggregateOutputType | null
    _max: JivoBotMaxAggregateOutputType | null
  }

  type GetJivoBotGroupByPayload<T extends JivoBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JivoBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JivoBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JivoBotGroupByOutputType[P]>
            : GetScalarType<T[P], JivoBotGroupByOutputType[P]>
        }
      >
    >


  export type JivoBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    settings?: boolean
    imageUrl?: boolean
    profileId?: boolean
    useCount?: boolean
    provider_id?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | AssistantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jivoBot"]>

  export type JivoBotSelectScalar = {
    id?: boolean
    name?: boolean
    settings?: boolean
    imageUrl?: boolean
    profileId?: boolean
    useCount?: boolean
    provider_id?: boolean
    assistantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JivoBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    assistant?: boolean | AssistantDefaultArgs<ExtArgs>
  }


  export type $JivoBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JivoBot"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      assistant: Prisma.$AssistantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      settings: string
      imageUrl: string
      profileId: string
      useCount: number
      provider_id: string
      assistantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jivoBot"]>
    composites: {}
  }


  type JivoBotGetPayload<S extends boolean | null | undefined | JivoBotDefaultArgs> = $Result.GetResult<Prisma.$JivoBotPayload, S>

  type JivoBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JivoBotFindManyArgs, 'select' | 'include'> & {
      select?: JivoBotCountAggregateInputType | true
    }

  export interface JivoBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JivoBot'], meta: { name: 'JivoBot' } }
    /**
     * Find zero or one JivoBot that matches the filter.
     * @param {JivoBotFindUniqueArgs} args - Arguments to find a JivoBot
     * @example
     * // Get one JivoBot
     * const jivoBot = await prisma.jivoBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JivoBotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JivoBotFindUniqueArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JivoBot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JivoBotFindUniqueOrThrowArgs} args - Arguments to find a JivoBot
     * @example
     * // Get one JivoBot
     * const jivoBot = await prisma.jivoBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JivoBotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JivoBotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JivoBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotFindFirstArgs} args - Arguments to find a JivoBot
     * @example
     * // Get one JivoBot
     * const jivoBot = await prisma.jivoBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JivoBotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JivoBotFindFirstArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JivoBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotFindFirstOrThrowArgs} args - Arguments to find a JivoBot
     * @example
     * // Get one JivoBot
     * const jivoBot = await prisma.jivoBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JivoBotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JivoBotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JivoBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JivoBots
     * const jivoBots = await prisma.jivoBot.findMany()
     * 
     * // Get first 10 JivoBots
     * const jivoBots = await prisma.jivoBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jivoBotWithIdOnly = await prisma.jivoBot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JivoBotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JivoBotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JivoBot.
     * @param {JivoBotCreateArgs} args - Arguments to create a JivoBot.
     * @example
     * // Create one JivoBot
     * const JivoBot = await prisma.jivoBot.create({
     *   data: {
     *     // ... data to create a JivoBot
     *   }
     * })
     * 
    **/
    create<T extends JivoBotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JivoBotCreateArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JivoBots.
     *     @param {JivoBotCreateManyArgs} args - Arguments to create many JivoBots.
     *     @example
     *     // Create many JivoBots
     *     const jivoBot = await prisma.jivoBot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JivoBotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JivoBotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JivoBot.
     * @param {JivoBotDeleteArgs} args - Arguments to delete one JivoBot.
     * @example
     * // Delete one JivoBot
     * const JivoBot = await prisma.jivoBot.delete({
     *   where: {
     *     // ... filter to delete one JivoBot
     *   }
     * })
     * 
    **/
    delete<T extends JivoBotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JivoBotDeleteArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JivoBot.
     * @param {JivoBotUpdateArgs} args - Arguments to update one JivoBot.
     * @example
     * // Update one JivoBot
     * const jivoBot = await prisma.jivoBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JivoBotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JivoBotUpdateArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JivoBots.
     * @param {JivoBotDeleteManyArgs} args - Arguments to filter JivoBots to delete.
     * @example
     * // Delete a few JivoBots
     * const { count } = await prisma.jivoBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JivoBotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JivoBotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JivoBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JivoBots
     * const jivoBot = await prisma.jivoBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JivoBotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JivoBotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JivoBot.
     * @param {JivoBotUpsertArgs} args - Arguments to update or create a JivoBot.
     * @example
     * // Update or create a JivoBot
     * const jivoBot = await prisma.jivoBot.upsert({
     *   create: {
     *     // ... data to create a JivoBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JivoBot we want to update
     *   }
     * })
    **/
    upsert<T extends JivoBotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JivoBotUpsertArgs<ExtArgs>>
    ): Prisma__JivoBotClient<$Result.GetResult<Prisma.$JivoBotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JivoBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotCountArgs} args - Arguments to filter JivoBots to count.
     * @example
     * // Count the number of JivoBots
     * const count = await prisma.jivoBot.count({
     *   where: {
     *     // ... the filter for the JivoBots we want to count
     *   }
     * })
    **/
    count<T extends JivoBotCountArgs>(
      args?: Subset<T, JivoBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JivoBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JivoBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JivoBotAggregateArgs>(args: Subset<T, JivoBotAggregateArgs>): Prisma.PrismaPromise<GetJivoBotAggregateType<T>>

    /**
     * Group by JivoBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JivoBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JivoBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JivoBotGroupByArgs['orderBy'] }
        : { orderBy?: JivoBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JivoBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJivoBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JivoBot model
   */
  readonly fields: JivoBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JivoBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JivoBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assistant<T extends AssistantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssistantDefaultArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JivoBot model
   */ 
  interface JivoBotFieldRefs {
    readonly id: FieldRef<"JivoBot", 'String'>
    readonly name: FieldRef<"JivoBot", 'String'>
    readonly settings: FieldRef<"JivoBot", 'String'>
    readonly imageUrl: FieldRef<"JivoBot", 'String'>
    readonly profileId: FieldRef<"JivoBot", 'String'>
    readonly useCount: FieldRef<"JivoBot", 'Int'>
    readonly provider_id: FieldRef<"JivoBot", 'String'>
    readonly assistantId: FieldRef<"JivoBot", 'String'>
    readonly createdAt: FieldRef<"JivoBot", 'DateTime'>
    readonly updatedAt: FieldRef<"JivoBot", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * JivoBot findUnique
   */
  export type JivoBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * Filter, which JivoBot to fetch.
     */
    where: JivoBotWhereUniqueInput
  }


  /**
   * JivoBot findUniqueOrThrow
   */
  export type JivoBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * Filter, which JivoBot to fetch.
     */
    where: JivoBotWhereUniqueInput
  }


  /**
   * JivoBot findFirst
   */
  export type JivoBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * Filter, which JivoBot to fetch.
     */
    where?: JivoBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JivoBots to fetch.
     */
    orderBy?: JivoBotOrderByWithRelationInput | JivoBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JivoBots.
     */
    cursor?: JivoBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JivoBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JivoBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JivoBots.
     */
    distinct?: JivoBotScalarFieldEnum | JivoBotScalarFieldEnum[]
  }


  /**
   * JivoBot findFirstOrThrow
   */
  export type JivoBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * Filter, which JivoBot to fetch.
     */
    where?: JivoBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JivoBots to fetch.
     */
    orderBy?: JivoBotOrderByWithRelationInput | JivoBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JivoBots.
     */
    cursor?: JivoBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JivoBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JivoBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JivoBots.
     */
    distinct?: JivoBotScalarFieldEnum | JivoBotScalarFieldEnum[]
  }


  /**
   * JivoBot findMany
   */
  export type JivoBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * Filter, which JivoBots to fetch.
     */
    where?: JivoBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JivoBots to fetch.
     */
    orderBy?: JivoBotOrderByWithRelationInput | JivoBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JivoBots.
     */
    cursor?: JivoBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JivoBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JivoBots.
     */
    skip?: number
    distinct?: JivoBotScalarFieldEnum | JivoBotScalarFieldEnum[]
  }


  /**
   * JivoBot create
   */
  export type JivoBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * The data needed to create a JivoBot.
     */
    data: XOR<JivoBotCreateInput, JivoBotUncheckedCreateInput>
  }


  /**
   * JivoBot createMany
   */
  export type JivoBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JivoBots.
     */
    data: JivoBotCreateManyInput | JivoBotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JivoBot update
   */
  export type JivoBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * The data needed to update a JivoBot.
     */
    data: XOR<JivoBotUpdateInput, JivoBotUncheckedUpdateInput>
    /**
     * Choose, which JivoBot to update.
     */
    where: JivoBotWhereUniqueInput
  }


  /**
   * JivoBot updateMany
   */
  export type JivoBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JivoBots.
     */
    data: XOR<JivoBotUpdateManyMutationInput, JivoBotUncheckedUpdateManyInput>
    /**
     * Filter which JivoBots to update
     */
    where?: JivoBotWhereInput
  }


  /**
   * JivoBot upsert
   */
  export type JivoBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * The filter to search for the JivoBot to update in case it exists.
     */
    where: JivoBotWhereUniqueInput
    /**
     * In case the JivoBot found by the `where` argument doesn't exist, create a new JivoBot with this data.
     */
    create: XOR<JivoBotCreateInput, JivoBotUncheckedCreateInput>
    /**
     * In case the JivoBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JivoBotUpdateInput, JivoBotUncheckedUpdateInput>
  }


  /**
   * JivoBot delete
   */
  export type JivoBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
    /**
     * Filter which JivoBot to delete.
     */
    where: JivoBotWhereUniqueInput
  }


  /**
   * JivoBot deleteMany
   */
  export type JivoBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JivoBots to delete
     */
    where?: JivoBotWhereInput
  }


  /**
   * JivoBot without action
   */
  export type JivoBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JivoBot
     */
    select?: JivoBotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JivoBotInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    imageUrl: 'imageUrl',
    login: 'login',
    password: 'password',
    email: 'email',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expires: 'expires'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const AssistantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    settings: 'settings',
    use_count: 'use_count',
    comment: 'comment',
    token: 'token',
    imageUrl: 'imageUrl',
    temperature: 'temperature',
    profileId: 'profileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssistantScalarFieldEnum = (typeof AssistantScalarFieldEnum)[keyof typeof AssistantScalarFieldEnum]


  export const TelegramBotScalarFieldEnum: {
    id: 'id',
    name: 'name',
    telegram_id: 'telegram_id',
    imageUrl: 'imageUrl',
    useCount: 'useCount',
    token: 'token',
    profileId: 'profileId',
    assistantId: 'assistantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramBotScalarFieldEnum = (typeof TelegramBotScalarFieldEnum)[keyof typeof TelegramBotScalarFieldEnum]


  export const TelegramUserBotScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    imageUrl: 'imageUrl',
    useCount: 'useCount',
    phone: 'phone',
    api_id: 'api_id',
    api_hash: 'api_hash',
    profileId: 'profileId',
    assistantId: 'assistantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramUserBotScalarFieldEnum = (typeof TelegramUserBotScalarFieldEnum)[keyof typeof TelegramUserBotScalarFieldEnum]


  export const WhatsAppBotScalarFieldEnum: {
    id: 'id',
    name: 'name',
    settings: 'settings',
    imageUrl: 'imageUrl',
    useCount: 'useCount',
    fullName: 'fullName',
    phone: 'phone',
    IdInstance: 'IdInstance',
    ApiTokenInstance: 'ApiTokenInstance',
    profileId: 'profileId',
    assistantId: 'assistantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppBotScalarFieldEnum = (typeof WhatsAppBotScalarFieldEnum)[keyof typeof WhatsAppBotScalarFieldEnum]


  export const JivoBotScalarFieldEnum: {
    id: 'id',
    name: 'name',
    settings: 'settings',
    imageUrl: 'imageUrl',
    profileId: 'profileId',
    useCount: 'useCount',
    provider_id: 'provider_id',
    assistantId: 'assistantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JivoBotScalarFieldEnum = (typeof JivoBotScalarFieldEnum)[keyof typeof JivoBotScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    imageUrl?: StringFilter<"Profile"> | string
    login?: StringNullableFilter<"Profile"> | string | null
    password?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    token?: StringFilter<"Profile"> | string
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    expires?: DateTimeFilter<"Profile"> | Date | string
    assistants?: AssistantListRelationFilter
    telegramBots?: TelegramBotListRelationFilter
    telegramUserBots?: TelegramUserBotListRelationFilter
    whatsAppBot?: WhatsAppBotListRelationFilter
    JivoBot?: JivoBotListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    login?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expires?: SortOrder
    assistants?: AssistantOrderByRelationAggregateInput
    telegramBots?: TelegramBotOrderByRelationAggregateInput
    telegramUserBots?: TelegramUserBotOrderByRelationAggregateInput
    whatsAppBot?: WhatsAppBotOrderByRelationAggregateInput
    JivoBot?: JivoBotOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    name?: StringFilter<"Profile"> | string
    imageUrl?: StringFilter<"Profile"> | string
    login?: StringNullableFilter<"Profile"> | string | null
    password?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    token?: StringFilter<"Profile"> | string
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    expires?: DateTimeFilter<"Profile"> | Date | string
    assistants?: AssistantListRelationFilter
    telegramBots?: TelegramBotListRelationFilter
    telegramUserBots?: TelegramUserBotListRelationFilter
    whatsAppBot?: WhatsAppBotListRelationFilter
    JivoBot?: JivoBotListRelationFilter
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    login?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expires?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    name?: StringWithAggregatesFilter<"Profile"> | string
    imageUrl?: StringWithAggregatesFilter<"Profile"> | string
    login?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    password?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    email?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    token?: StringWithAggregatesFilter<"Profile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    expires?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type AssistantWhereInput = {
    AND?: AssistantWhereInput | AssistantWhereInput[]
    OR?: AssistantWhereInput[]
    NOT?: AssistantWhereInput | AssistantWhereInput[]
    id?: StringFilter<"Assistant"> | string
    name?: StringFilter<"Assistant"> | string
    settings?: StringFilter<"Assistant"> | string
    use_count?: IntFilter<"Assistant"> | number
    comment?: StringFilter<"Assistant"> | string
    token?: StringFilter<"Assistant"> | string
    imageUrl?: StringFilter<"Assistant"> | string
    temperature?: FloatFilter<"Assistant"> | number
    profileId?: StringFilter<"Assistant"> | string
    createdAt?: DateTimeFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeFilter<"Assistant"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    telegramBots?: TelegramBotListRelationFilter
    telegramUserBots?: TelegramUserBotListRelationFilter
    whatsAppBot?: WhatsAppBotListRelationFilter
    jivoBot?: JivoBotListRelationFilter
  }

  export type AssistantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    use_count?: SortOrder
    comment?: SortOrder
    token?: SortOrder
    imageUrl?: SortOrder
    temperature?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    telegramBots?: TelegramBotOrderByRelationAggregateInput
    telegramUserBots?: TelegramUserBotOrderByRelationAggregateInput
    whatsAppBot?: WhatsAppBotOrderByRelationAggregateInput
    jivoBot?: JivoBotOrderByRelationAggregateInput
  }

  export type AssistantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssistantWhereInput | AssistantWhereInput[]
    OR?: AssistantWhereInput[]
    NOT?: AssistantWhereInput | AssistantWhereInput[]
    name?: StringFilter<"Assistant"> | string
    settings?: StringFilter<"Assistant"> | string
    use_count?: IntFilter<"Assistant"> | number
    comment?: StringFilter<"Assistant"> | string
    token?: StringFilter<"Assistant"> | string
    imageUrl?: StringFilter<"Assistant"> | string
    temperature?: FloatFilter<"Assistant"> | number
    profileId?: StringFilter<"Assistant"> | string
    createdAt?: DateTimeFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeFilter<"Assistant"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    telegramBots?: TelegramBotListRelationFilter
    telegramUserBots?: TelegramUserBotListRelationFilter
    whatsAppBot?: WhatsAppBotListRelationFilter
    jivoBot?: JivoBotListRelationFilter
  }, "id">

  export type AssistantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    use_count?: SortOrder
    comment?: SortOrder
    token?: SortOrder
    imageUrl?: SortOrder
    temperature?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssistantCountOrderByAggregateInput
    _avg?: AssistantAvgOrderByAggregateInput
    _max?: AssistantMaxOrderByAggregateInput
    _min?: AssistantMinOrderByAggregateInput
    _sum?: AssistantSumOrderByAggregateInput
  }

  export type AssistantScalarWhereWithAggregatesInput = {
    AND?: AssistantScalarWhereWithAggregatesInput | AssistantScalarWhereWithAggregatesInput[]
    OR?: AssistantScalarWhereWithAggregatesInput[]
    NOT?: AssistantScalarWhereWithAggregatesInput | AssistantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assistant"> | string
    name?: StringWithAggregatesFilter<"Assistant"> | string
    settings?: StringWithAggregatesFilter<"Assistant"> | string
    use_count?: IntWithAggregatesFilter<"Assistant"> | number
    comment?: StringWithAggregatesFilter<"Assistant"> | string
    token?: StringWithAggregatesFilter<"Assistant"> | string
    imageUrl?: StringWithAggregatesFilter<"Assistant"> | string
    temperature?: FloatWithAggregatesFilter<"Assistant"> | number
    profileId?: StringWithAggregatesFilter<"Assistant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assistant"> | Date | string
  }

  export type TelegramBotWhereInput = {
    AND?: TelegramBotWhereInput | TelegramBotWhereInput[]
    OR?: TelegramBotWhereInput[]
    NOT?: TelegramBotWhereInput | TelegramBotWhereInput[]
    id?: StringFilter<"TelegramBot"> | string
    name?: StringFilter<"TelegramBot"> | string
    telegram_id?: StringFilter<"TelegramBot"> | string
    imageUrl?: StringFilter<"TelegramBot"> | string
    useCount?: IntFilter<"TelegramBot"> | number
    token?: StringFilter<"TelegramBot"> | string
    profileId?: StringFilter<"TelegramBot"> | string
    assistantId?: StringNullableFilter<"TelegramBot"> | string | null
    createdAt?: DateTimeFilter<"TelegramBot"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantNullableRelationFilter, AssistantWhereInput> | null
  }

  export type TelegramBotOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    telegram_id?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    token?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    assistant?: AssistantOrderByWithRelationInput
  }

  export type TelegramBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TelegramBotWhereInput | TelegramBotWhereInput[]
    OR?: TelegramBotWhereInput[]
    NOT?: TelegramBotWhereInput | TelegramBotWhereInput[]
    name?: StringFilter<"TelegramBot"> | string
    telegram_id?: StringFilter<"TelegramBot"> | string
    imageUrl?: StringFilter<"TelegramBot"> | string
    useCount?: IntFilter<"TelegramBot"> | number
    token?: StringFilter<"TelegramBot"> | string
    profileId?: StringFilter<"TelegramBot"> | string
    assistantId?: StringNullableFilter<"TelegramBot"> | string | null
    createdAt?: DateTimeFilter<"TelegramBot"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantNullableRelationFilter, AssistantWhereInput> | null
  }, "id">

  export type TelegramBotOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    telegram_id?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    token?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramBotCountOrderByAggregateInput
    _avg?: TelegramBotAvgOrderByAggregateInput
    _max?: TelegramBotMaxOrderByAggregateInput
    _min?: TelegramBotMinOrderByAggregateInput
    _sum?: TelegramBotSumOrderByAggregateInput
  }

  export type TelegramBotScalarWhereWithAggregatesInput = {
    AND?: TelegramBotScalarWhereWithAggregatesInput | TelegramBotScalarWhereWithAggregatesInput[]
    OR?: TelegramBotScalarWhereWithAggregatesInput[]
    NOT?: TelegramBotScalarWhereWithAggregatesInput | TelegramBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelegramBot"> | string
    name?: StringWithAggregatesFilter<"TelegramBot"> | string
    telegram_id?: StringWithAggregatesFilter<"TelegramBot"> | string
    imageUrl?: StringWithAggregatesFilter<"TelegramBot"> | string
    useCount?: IntWithAggregatesFilter<"TelegramBot"> | number
    token?: StringWithAggregatesFilter<"TelegramBot"> | string
    profileId?: StringWithAggregatesFilter<"TelegramBot"> | string
    assistantId?: StringNullableWithAggregatesFilter<"TelegramBot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TelegramBot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramBot"> | Date | string
  }

  export type TelegramUserBotWhereInput = {
    AND?: TelegramUserBotWhereInput | TelegramUserBotWhereInput[]
    OR?: TelegramUserBotWhereInput[]
    NOT?: TelegramUserBotWhereInput | TelegramUserBotWhereInput[]
    id?: StringFilter<"TelegramUserBot"> | string
    firstName?: StringFilter<"TelegramUserBot"> | string
    lastName?: StringFilter<"TelegramUserBot"> | string
    username?: StringFilter<"TelegramUserBot"> | string
    imageUrl?: StringFilter<"TelegramUserBot"> | string
    useCount?: IntFilter<"TelegramUserBot"> | number
    phone?: StringFilter<"TelegramUserBot"> | string
    api_id?: StringFilter<"TelegramUserBot"> | string
    api_hash?: StringFilter<"TelegramUserBot"> | string
    profileId?: StringFilter<"TelegramUserBot"> | string
    assistantId?: StringFilter<"TelegramUserBot"> | string
    createdAt?: DateTimeFilter<"TelegramUserBot"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramUserBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantRelationFilter, AssistantWhereInput>
  }

  export type TelegramUserBotOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    phone?: SortOrder
    api_id?: SortOrder
    api_hash?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    assistant?: AssistantOrderByWithRelationInput
  }

  export type TelegramUserBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TelegramUserBotWhereInput | TelegramUserBotWhereInput[]
    OR?: TelegramUserBotWhereInput[]
    NOT?: TelegramUserBotWhereInput | TelegramUserBotWhereInput[]
    firstName?: StringFilter<"TelegramUserBot"> | string
    lastName?: StringFilter<"TelegramUserBot"> | string
    username?: StringFilter<"TelegramUserBot"> | string
    imageUrl?: StringFilter<"TelegramUserBot"> | string
    useCount?: IntFilter<"TelegramUserBot"> | number
    phone?: StringFilter<"TelegramUserBot"> | string
    api_id?: StringFilter<"TelegramUserBot"> | string
    api_hash?: StringFilter<"TelegramUserBot"> | string
    profileId?: StringFilter<"TelegramUserBot"> | string
    assistantId?: StringFilter<"TelegramUserBot"> | string
    createdAt?: DateTimeFilter<"TelegramUserBot"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramUserBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantRelationFilter, AssistantWhereInput>
  }, "id">

  export type TelegramUserBotOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    phone?: SortOrder
    api_id?: SortOrder
    api_hash?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramUserBotCountOrderByAggregateInput
    _avg?: TelegramUserBotAvgOrderByAggregateInput
    _max?: TelegramUserBotMaxOrderByAggregateInput
    _min?: TelegramUserBotMinOrderByAggregateInput
    _sum?: TelegramUserBotSumOrderByAggregateInput
  }

  export type TelegramUserBotScalarWhereWithAggregatesInput = {
    AND?: TelegramUserBotScalarWhereWithAggregatesInput | TelegramUserBotScalarWhereWithAggregatesInput[]
    OR?: TelegramUserBotScalarWhereWithAggregatesInput[]
    NOT?: TelegramUserBotScalarWhereWithAggregatesInput | TelegramUserBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    firstName?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    lastName?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    username?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    imageUrl?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    useCount?: IntWithAggregatesFilter<"TelegramUserBot"> | number
    phone?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    api_id?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    api_hash?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    profileId?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    assistantId?: StringWithAggregatesFilter<"TelegramUserBot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TelegramUserBot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramUserBot"> | Date | string
  }

  export type WhatsAppBotWhereInput = {
    AND?: WhatsAppBotWhereInput | WhatsAppBotWhereInput[]
    OR?: WhatsAppBotWhereInput[]
    NOT?: WhatsAppBotWhereInput | WhatsAppBotWhereInput[]
    id?: StringFilter<"WhatsAppBot"> | string
    name?: StringFilter<"WhatsAppBot"> | string
    settings?: StringFilter<"WhatsAppBot"> | string
    imageUrl?: StringFilter<"WhatsAppBot"> | string
    useCount?: IntFilter<"WhatsAppBot"> | number
    fullName?: StringFilter<"WhatsAppBot"> | string
    phone?: StringFilter<"WhatsAppBot"> | string
    IdInstance?: StringFilter<"WhatsAppBot"> | string
    ApiTokenInstance?: StringFilter<"WhatsAppBot"> | string
    profileId?: StringFilter<"WhatsAppBot"> | string
    assistantId?: StringFilter<"WhatsAppBot"> | string
    createdAt?: DateTimeFilter<"WhatsAppBot"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantRelationFilter, AssistantWhereInput>
  }

  export type WhatsAppBotOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    IdInstance?: SortOrder
    ApiTokenInstance?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    assistant?: AssistantOrderByWithRelationInput
  }

  export type WhatsAppBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppBotWhereInput | WhatsAppBotWhereInput[]
    OR?: WhatsAppBotWhereInput[]
    NOT?: WhatsAppBotWhereInput | WhatsAppBotWhereInput[]
    name?: StringFilter<"WhatsAppBot"> | string
    settings?: StringFilter<"WhatsAppBot"> | string
    imageUrl?: StringFilter<"WhatsAppBot"> | string
    useCount?: IntFilter<"WhatsAppBot"> | number
    fullName?: StringFilter<"WhatsAppBot"> | string
    phone?: StringFilter<"WhatsAppBot"> | string
    IdInstance?: StringFilter<"WhatsAppBot"> | string
    ApiTokenInstance?: StringFilter<"WhatsAppBot"> | string
    profileId?: StringFilter<"WhatsAppBot"> | string
    assistantId?: StringFilter<"WhatsAppBot"> | string
    createdAt?: DateTimeFilter<"WhatsAppBot"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantRelationFilter, AssistantWhereInput>
  }, "id">

  export type WhatsAppBotOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    IdInstance?: SortOrder
    ApiTokenInstance?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppBotCountOrderByAggregateInput
    _avg?: WhatsAppBotAvgOrderByAggregateInput
    _max?: WhatsAppBotMaxOrderByAggregateInput
    _min?: WhatsAppBotMinOrderByAggregateInput
    _sum?: WhatsAppBotSumOrderByAggregateInput
  }

  export type WhatsAppBotScalarWhereWithAggregatesInput = {
    AND?: WhatsAppBotScalarWhereWithAggregatesInput | WhatsAppBotScalarWhereWithAggregatesInput[]
    OR?: WhatsAppBotScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppBotScalarWhereWithAggregatesInput | WhatsAppBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    name?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    settings?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    imageUrl?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    useCount?: IntWithAggregatesFilter<"WhatsAppBot"> | number
    fullName?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    phone?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    IdInstance?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    ApiTokenInstance?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    profileId?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    assistantId?: StringWithAggregatesFilter<"WhatsAppBot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppBot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppBot"> | Date | string
  }

  export type JivoBotWhereInput = {
    AND?: JivoBotWhereInput | JivoBotWhereInput[]
    OR?: JivoBotWhereInput[]
    NOT?: JivoBotWhereInput | JivoBotWhereInput[]
    id?: StringFilter<"JivoBot"> | string
    name?: StringFilter<"JivoBot"> | string
    settings?: StringFilter<"JivoBot"> | string
    imageUrl?: StringFilter<"JivoBot"> | string
    profileId?: StringFilter<"JivoBot"> | string
    useCount?: IntFilter<"JivoBot"> | number
    provider_id?: StringFilter<"JivoBot"> | string
    assistantId?: StringFilter<"JivoBot"> | string
    createdAt?: DateTimeFilter<"JivoBot"> | Date | string
    updatedAt?: DateTimeFilter<"JivoBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantRelationFilter, AssistantWhereInput>
  }

  export type JivoBotOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    profileId?: SortOrder
    useCount?: SortOrder
    provider_id?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    assistant?: AssistantOrderByWithRelationInput
  }

  export type JivoBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JivoBotWhereInput | JivoBotWhereInput[]
    OR?: JivoBotWhereInput[]
    NOT?: JivoBotWhereInput | JivoBotWhereInput[]
    name?: StringFilter<"JivoBot"> | string
    settings?: StringFilter<"JivoBot"> | string
    imageUrl?: StringFilter<"JivoBot"> | string
    profileId?: StringFilter<"JivoBot"> | string
    useCount?: IntFilter<"JivoBot"> | number
    provider_id?: StringFilter<"JivoBot"> | string
    assistantId?: StringFilter<"JivoBot"> | string
    createdAt?: DateTimeFilter<"JivoBot"> | Date | string
    updatedAt?: DateTimeFilter<"JivoBot"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    assistant?: XOR<AssistantRelationFilter, AssistantWhereInput>
  }, "id">

  export type JivoBotOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    profileId?: SortOrder
    useCount?: SortOrder
    provider_id?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JivoBotCountOrderByAggregateInput
    _avg?: JivoBotAvgOrderByAggregateInput
    _max?: JivoBotMaxOrderByAggregateInput
    _min?: JivoBotMinOrderByAggregateInput
    _sum?: JivoBotSumOrderByAggregateInput
  }

  export type JivoBotScalarWhereWithAggregatesInput = {
    AND?: JivoBotScalarWhereWithAggregatesInput | JivoBotScalarWhereWithAggregatesInput[]
    OR?: JivoBotScalarWhereWithAggregatesInput[]
    NOT?: JivoBotScalarWhereWithAggregatesInput | JivoBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JivoBot"> | string
    name?: StringWithAggregatesFilter<"JivoBot"> | string
    settings?: StringWithAggregatesFilter<"JivoBot"> | string
    imageUrl?: StringWithAggregatesFilter<"JivoBot"> | string
    profileId?: StringWithAggregatesFilter<"JivoBot"> | string
    useCount?: IntWithAggregatesFilter<"JivoBot"> | number
    provider_id?: StringWithAggregatesFilter<"JivoBot"> | string
    assistantId?: StringWithAggregatesFilter<"JivoBot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JivoBot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JivoBot"> | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantUncheckedCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUncheckedUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssistantCreateInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutAssistantsInput
    telegramBots?: TelegramBotCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUncheckedCreateInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutAssistantsNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantCreateManyInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssistantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssistantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotCreateInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTelegramBotsInput
    assistant?: AssistantCreateNestedOneWithoutTelegramBotsInput
  }

  export type TelegramBotUncheckedCreateInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    profileId: string
    assistantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTelegramBotsNestedInput
    assistant?: AssistantUpdateOneWithoutTelegramBotsNestedInput
  }

  export type TelegramBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotCreateManyInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    profileId: string
    assistantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotCreateInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTelegramUserBotsInput
    assistant: AssistantCreateNestedOneWithoutTelegramUserBotsInput
  }

  export type TelegramUserBotUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    profileId: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTelegramUserBotsNestedInput
    assistant?: AssistantUpdateOneRequiredWithoutTelegramUserBotsNestedInput
  }

  export type TelegramUserBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    profileId: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotCreateInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutWhatsAppBotInput
    assistant: AssistantCreateNestedOneWithoutWhatsAppBotInput
  }

  export type WhatsAppBotUncheckedCreateInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    profileId: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutWhatsAppBotNestedInput
    assistant?: AssistantUpdateOneRequiredWithoutWhatsAppBotNestedInput
  }

  export type WhatsAppBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotCreateManyInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    profileId: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotCreateInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    provider_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutJivoBotInput
    assistant: AssistantCreateNestedOneWithoutJivoBotInput
  }

  export type JivoBotUncheckedCreateInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    profileId: string
    useCount?: number
    provider_id: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JivoBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutJivoBotNestedInput
    assistant?: AssistantUpdateOneRequiredWithoutJivoBotNestedInput
  }

  export type JivoBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotCreateManyInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    profileId: string
    useCount?: number
    provider_id: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JivoBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AssistantListRelationFilter = {
    every?: AssistantWhereInput
    some?: AssistantWhereInput
    none?: AssistantWhereInput
  }

  export type TelegramBotListRelationFilter = {
    every?: TelegramBotWhereInput
    some?: TelegramBotWhereInput
    none?: TelegramBotWhereInput
  }

  export type TelegramUserBotListRelationFilter = {
    every?: TelegramUserBotWhereInput
    some?: TelegramUserBotWhereInput
    none?: TelegramUserBotWhereInput
  }

  export type WhatsAppBotListRelationFilter = {
    every?: WhatsAppBotWhereInput
    some?: WhatsAppBotWhereInput
    none?: WhatsAppBotWhereInput
  }

  export type JivoBotListRelationFilter = {
    every?: JivoBotWhereInput
    some?: JivoBotWhereInput
    none?: JivoBotWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AssistantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramUserBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JivoBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    login?: SortOrder
    password?: SortOrder
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expires?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    login?: SortOrder
    password?: SortOrder
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expires?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    login?: SortOrder
    password?: SortOrder
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expires?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type AssistantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    use_count?: SortOrder
    comment?: SortOrder
    token?: SortOrder
    imageUrl?: SortOrder
    temperature?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssistantAvgOrderByAggregateInput = {
    use_count?: SortOrder
    temperature?: SortOrder
  }

  export type AssistantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    use_count?: SortOrder
    comment?: SortOrder
    token?: SortOrder
    imageUrl?: SortOrder
    temperature?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssistantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    use_count?: SortOrder
    comment?: SortOrder
    token?: SortOrder
    imageUrl?: SortOrder
    temperature?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssistantSumOrderByAggregateInput = {
    use_count?: SortOrder
    temperature?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AssistantNullableRelationFilter = {
    is?: AssistantWhereInput | null
    isNot?: AssistantWhereInput | null
  }

  export type TelegramBotCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    telegram_id?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    token?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramBotAvgOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type TelegramBotMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    telegram_id?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    token?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramBotMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    telegram_id?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    token?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramBotSumOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type AssistantRelationFilter = {
    is?: AssistantWhereInput
    isNot?: AssistantWhereInput
  }

  export type TelegramUserBotCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    phone?: SortOrder
    api_id?: SortOrder
    api_hash?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramUserBotAvgOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type TelegramUserBotMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    phone?: SortOrder
    api_id?: SortOrder
    api_hash?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramUserBotMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    phone?: SortOrder
    api_id?: SortOrder
    api_hash?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramUserBotSumOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type WhatsAppBotCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    IdInstance?: SortOrder
    ApiTokenInstance?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppBotAvgOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type WhatsAppBotMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    IdInstance?: SortOrder
    ApiTokenInstance?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppBotMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    useCount?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    IdInstance?: SortOrder
    ApiTokenInstance?: SortOrder
    profileId?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppBotSumOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type JivoBotCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    profileId?: SortOrder
    useCount?: SortOrder
    provider_id?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JivoBotAvgOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type JivoBotMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    profileId?: SortOrder
    useCount?: SortOrder
    provider_id?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JivoBotMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    profileId?: SortOrder
    useCount?: SortOrder
    provider_id?: SortOrder
    assistantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JivoBotSumOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type AssistantCreateNestedManyWithoutProfileInput = {
    create?: XOR<AssistantCreateWithoutProfileInput, AssistantUncheckedCreateWithoutProfileInput> | AssistantCreateWithoutProfileInput[] | AssistantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutProfileInput | AssistantCreateOrConnectWithoutProfileInput[]
    createMany?: AssistantCreateManyProfileInputEnvelope
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
  }

  export type TelegramBotCreateNestedManyWithoutProfileInput = {
    create?: XOR<TelegramBotCreateWithoutProfileInput, TelegramBotUncheckedCreateWithoutProfileInput> | TelegramBotCreateWithoutProfileInput[] | TelegramBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutProfileInput | TelegramBotCreateOrConnectWithoutProfileInput[]
    createMany?: TelegramBotCreateManyProfileInputEnvelope
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
  }

  export type TelegramUserBotCreateNestedManyWithoutProfileInput = {
    create?: XOR<TelegramUserBotCreateWithoutProfileInput, TelegramUserBotUncheckedCreateWithoutProfileInput> | TelegramUserBotCreateWithoutProfileInput[] | TelegramUserBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutProfileInput | TelegramUserBotCreateOrConnectWithoutProfileInput[]
    createMany?: TelegramUserBotCreateManyProfileInputEnvelope
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
  }

  export type WhatsAppBotCreateNestedManyWithoutProfileInput = {
    create?: XOR<WhatsAppBotCreateWithoutProfileInput, WhatsAppBotUncheckedCreateWithoutProfileInput> | WhatsAppBotCreateWithoutProfileInput[] | WhatsAppBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutProfileInput | WhatsAppBotCreateOrConnectWithoutProfileInput[]
    createMany?: WhatsAppBotCreateManyProfileInputEnvelope
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
  }

  export type JivoBotCreateNestedManyWithoutProfileInput = {
    create?: XOR<JivoBotCreateWithoutProfileInput, JivoBotUncheckedCreateWithoutProfileInput> | JivoBotCreateWithoutProfileInput[] | JivoBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutProfileInput | JivoBotCreateOrConnectWithoutProfileInput[]
    createMany?: JivoBotCreateManyProfileInputEnvelope
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
  }

  export type AssistantUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<AssistantCreateWithoutProfileInput, AssistantUncheckedCreateWithoutProfileInput> | AssistantCreateWithoutProfileInput[] | AssistantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutProfileInput | AssistantCreateOrConnectWithoutProfileInput[]
    createMany?: AssistantCreateManyProfileInputEnvelope
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
  }

  export type TelegramBotUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<TelegramBotCreateWithoutProfileInput, TelegramBotUncheckedCreateWithoutProfileInput> | TelegramBotCreateWithoutProfileInput[] | TelegramBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutProfileInput | TelegramBotCreateOrConnectWithoutProfileInput[]
    createMany?: TelegramBotCreateManyProfileInputEnvelope
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
  }

  export type TelegramUserBotUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<TelegramUserBotCreateWithoutProfileInput, TelegramUserBotUncheckedCreateWithoutProfileInput> | TelegramUserBotCreateWithoutProfileInput[] | TelegramUserBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutProfileInput | TelegramUserBotCreateOrConnectWithoutProfileInput[]
    createMany?: TelegramUserBotCreateManyProfileInputEnvelope
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
  }

  export type WhatsAppBotUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<WhatsAppBotCreateWithoutProfileInput, WhatsAppBotUncheckedCreateWithoutProfileInput> | WhatsAppBotCreateWithoutProfileInput[] | WhatsAppBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutProfileInput | WhatsAppBotCreateOrConnectWithoutProfileInput[]
    createMany?: WhatsAppBotCreateManyProfileInputEnvelope
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
  }

  export type JivoBotUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<JivoBotCreateWithoutProfileInput, JivoBotUncheckedCreateWithoutProfileInput> | JivoBotCreateWithoutProfileInput[] | JivoBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutProfileInput | JivoBotCreateOrConnectWithoutProfileInput[]
    createMany?: JivoBotCreateManyProfileInputEnvelope
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AssistantUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AssistantCreateWithoutProfileInput, AssistantUncheckedCreateWithoutProfileInput> | AssistantCreateWithoutProfileInput[] | AssistantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutProfileInput | AssistantCreateOrConnectWithoutProfileInput[]
    upsert?: AssistantUpsertWithWhereUniqueWithoutProfileInput | AssistantUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AssistantCreateManyProfileInputEnvelope
    set?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    disconnect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    delete?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    update?: AssistantUpdateWithWhereUniqueWithoutProfileInput | AssistantUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AssistantUpdateManyWithWhereWithoutProfileInput | AssistantUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
  }

  export type TelegramBotUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TelegramBotCreateWithoutProfileInput, TelegramBotUncheckedCreateWithoutProfileInput> | TelegramBotCreateWithoutProfileInput[] | TelegramBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutProfileInput | TelegramBotCreateOrConnectWithoutProfileInput[]
    upsert?: TelegramBotUpsertWithWhereUniqueWithoutProfileInput | TelegramBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TelegramBotCreateManyProfileInputEnvelope
    set?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    disconnect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    delete?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    update?: TelegramBotUpdateWithWhereUniqueWithoutProfileInput | TelegramBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TelegramBotUpdateManyWithWhereWithoutProfileInput | TelegramBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TelegramBotScalarWhereInput | TelegramBotScalarWhereInput[]
  }

  export type TelegramUserBotUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TelegramUserBotCreateWithoutProfileInput, TelegramUserBotUncheckedCreateWithoutProfileInput> | TelegramUserBotCreateWithoutProfileInput[] | TelegramUserBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutProfileInput | TelegramUserBotCreateOrConnectWithoutProfileInput[]
    upsert?: TelegramUserBotUpsertWithWhereUniqueWithoutProfileInput | TelegramUserBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TelegramUserBotCreateManyProfileInputEnvelope
    set?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    disconnect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    delete?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    update?: TelegramUserBotUpdateWithWhereUniqueWithoutProfileInput | TelegramUserBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TelegramUserBotUpdateManyWithWhereWithoutProfileInput | TelegramUserBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TelegramUserBotScalarWhereInput | TelegramUserBotScalarWhereInput[]
  }

  export type WhatsAppBotUpdateManyWithoutProfileNestedInput = {
    create?: XOR<WhatsAppBotCreateWithoutProfileInput, WhatsAppBotUncheckedCreateWithoutProfileInput> | WhatsAppBotCreateWithoutProfileInput[] | WhatsAppBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutProfileInput | WhatsAppBotCreateOrConnectWithoutProfileInput[]
    upsert?: WhatsAppBotUpsertWithWhereUniqueWithoutProfileInput | WhatsAppBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: WhatsAppBotCreateManyProfileInputEnvelope
    set?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    disconnect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    delete?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    update?: WhatsAppBotUpdateWithWhereUniqueWithoutProfileInput | WhatsAppBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: WhatsAppBotUpdateManyWithWhereWithoutProfileInput | WhatsAppBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: WhatsAppBotScalarWhereInput | WhatsAppBotScalarWhereInput[]
  }

  export type JivoBotUpdateManyWithoutProfileNestedInput = {
    create?: XOR<JivoBotCreateWithoutProfileInput, JivoBotUncheckedCreateWithoutProfileInput> | JivoBotCreateWithoutProfileInput[] | JivoBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutProfileInput | JivoBotCreateOrConnectWithoutProfileInput[]
    upsert?: JivoBotUpsertWithWhereUniqueWithoutProfileInput | JivoBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: JivoBotCreateManyProfileInputEnvelope
    set?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    disconnect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    delete?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    update?: JivoBotUpdateWithWhereUniqueWithoutProfileInput | JivoBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: JivoBotUpdateManyWithWhereWithoutProfileInput | JivoBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: JivoBotScalarWhereInput | JivoBotScalarWhereInput[]
  }

  export type AssistantUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AssistantCreateWithoutProfileInput, AssistantUncheckedCreateWithoutProfileInput> | AssistantCreateWithoutProfileInput[] | AssistantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutProfileInput | AssistantCreateOrConnectWithoutProfileInput[]
    upsert?: AssistantUpsertWithWhereUniqueWithoutProfileInput | AssistantUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AssistantCreateManyProfileInputEnvelope
    set?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    disconnect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    delete?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    update?: AssistantUpdateWithWhereUniqueWithoutProfileInput | AssistantUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AssistantUpdateManyWithWhereWithoutProfileInput | AssistantUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
  }

  export type TelegramBotUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TelegramBotCreateWithoutProfileInput, TelegramBotUncheckedCreateWithoutProfileInput> | TelegramBotCreateWithoutProfileInput[] | TelegramBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutProfileInput | TelegramBotCreateOrConnectWithoutProfileInput[]
    upsert?: TelegramBotUpsertWithWhereUniqueWithoutProfileInput | TelegramBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TelegramBotCreateManyProfileInputEnvelope
    set?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    disconnect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    delete?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    update?: TelegramBotUpdateWithWhereUniqueWithoutProfileInput | TelegramBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TelegramBotUpdateManyWithWhereWithoutProfileInput | TelegramBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TelegramBotScalarWhereInput | TelegramBotScalarWhereInput[]
  }

  export type TelegramUserBotUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TelegramUserBotCreateWithoutProfileInput, TelegramUserBotUncheckedCreateWithoutProfileInput> | TelegramUserBotCreateWithoutProfileInput[] | TelegramUserBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutProfileInput | TelegramUserBotCreateOrConnectWithoutProfileInput[]
    upsert?: TelegramUserBotUpsertWithWhereUniqueWithoutProfileInput | TelegramUserBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TelegramUserBotCreateManyProfileInputEnvelope
    set?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    disconnect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    delete?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    update?: TelegramUserBotUpdateWithWhereUniqueWithoutProfileInput | TelegramUserBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TelegramUserBotUpdateManyWithWhereWithoutProfileInput | TelegramUserBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TelegramUserBotScalarWhereInput | TelegramUserBotScalarWhereInput[]
  }

  export type WhatsAppBotUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<WhatsAppBotCreateWithoutProfileInput, WhatsAppBotUncheckedCreateWithoutProfileInput> | WhatsAppBotCreateWithoutProfileInput[] | WhatsAppBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutProfileInput | WhatsAppBotCreateOrConnectWithoutProfileInput[]
    upsert?: WhatsAppBotUpsertWithWhereUniqueWithoutProfileInput | WhatsAppBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: WhatsAppBotCreateManyProfileInputEnvelope
    set?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    disconnect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    delete?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    update?: WhatsAppBotUpdateWithWhereUniqueWithoutProfileInput | WhatsAppBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: WhatsAppBotUpdateManyWithWhereWithoutProfileInput | WhatsAppBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: WhatsAppBotScalarWhereInput | WhatsAppBotScalarWhereInput[]
  }

  export type JivoBotUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<JivoBotCreateWithoutProfileInput, JivoBotUncheckedCreateWithoutProfileInput> | JivoBotCreateWithoutProfileInput[] | JivoBotUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutProfileInput | JivoBotCreateOrConnectWithoutProfileInput[]
    upsert?: JivoBotUpsertWithWhereUniqueWithoutProfileInput | JivoBotUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: JivoBotCreateManyProfileInputEnvelope
    set?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    disconnect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    delete?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    update?: JivoBotUpdateWithWhereUniqueWithoutProfileInput | JivoBotUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: JivoBotUpdateManyWithWhereWithoutProfileInput | JivoBotUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: JivoBotScalarWhereInput | JivoBotScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutAssistantsInput = {
    create?: XOR<ProfileCreateWithoutAssistantsInput, ProfileUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAssistantsInput
    connect?: ProfileWhereUniqueInput
  }

  export type TelegramBotCreateNestedManyWithoutAssistantInput = {
    create?: XOR<TelegramBotCreateWithoutAssistantInput, TelegramBotUncheckedCreateWithoutAssistantInput> | TelegramBotCreateWithoutAssistantInput[] | TelegramBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutAssistantInput | TelegramBotCreateOrConnectWithoutAssistantInput[]
    createMany?: TelegramBotCreateManyAssistantInputEnvelope
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
  }

  export type TelegramUserBotCreateNestedManyWithoutAssistantInput = {
    create?: XOR<TelegramUserBotCreateWithoutAssistantInput, TelegramUserBotUncheckedCreateWithoutAssistantInput> | TelegramUserBotCreateWithoutAssistantInput[] | TelegramUserBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutAssistantInput | TelegramUserBotCreateOrConnectWithoutAssistantInput[]
    createMany?: TelegramUserBotCreateManyAssistantInputEnvelope
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
  }

  export type WhatsAppBotCreateNestedManyWithoutAssistantInput = {
    create?: XOR<WhatsAppBotCreateWithoutAssistantInput, WhatsAppBotUncheckedCreateWithoutAssistantInput> | WhatsAppBotCreateWithoutAssistantInput[] | WhatsAppBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutAssistantInput | WhatsAppBotCreateOrConnectWithoutAssistantInput[]
    createMany?: WhatsAppBotCreateManyAssistantInputEnvelope
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
  }

  export type JivoBotCreateNestedManyWithoutAssistantInput = {
    create?: XOR<JivoBotCreateWithoutAssistantInput, JivoBotUncheckedCreateWithoutAssistantInput> | JivoBotCreateWithoutAssistantInput[] | JivoBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutAssistantInput | JivoBotCreateOrConnectWithoutAssistantInput[]
    createMany?: JivoBotCreateManyAssistantInputEnvelope
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
  }

  export type TelegramBotUncheckedCreateNestedManyWithoutAssistantInput = {
    create?: XOR<TelegramBotCreateWithoutAssistantInput, TelegramBotUncheckedCreateWithoutAssistantInput> | TelegramBotCreateWithoutAssistantInput[] | TelegramBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutAssistantInput | TelegramBotCreateOrConnectWithoutAssistantInput[]
    createMany?: TelegramBotCreateManyAssistantInputEnvelope
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
  }

  export type TelegramUserBotUncheckedCreateNestedManyWithoutAssistantInput = {
    create?: XOR<TelegramUserBotCreateWithoutAssistantInput, TelegramUserBotUncheckedCreateWithoutAssistantInput> | TelegramUserBotCreateWithoutAssistantInput[] | TelegramUserBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutAssistantInput | TelegramUserBotCreateOrConnectWithoutAssistantInput[]
    createMany?: TelegramUserBotCreateManyAssistantInputEnvelope
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
  }

  export type WhatsAppBotUncheckedCreateNestedManyWithoutAssistantInput = {
    create?: XOR<WhatsAppBotCreateWithoutAssistantInput, WhatsAppBotUncheckedCreateWithoutAssistantInput> | WhatsAppBotCreateWithoutAssistantInput[] | WhatsAppBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutAssistantInput | WhatsAppBotCreateOrConnectWithoutAssistantInput[]
    createMany?: WhatsAppBotCreateManyAssistantInputEnvelope
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
  }

  export type JivoBotUncheckedCreateNestedManyWithoutAssistantInput = {
    create?: XOR<JivoBotCreateWithoutAssistantInput, JivoBotUncheckedCreateWithoutAssistantInput> | JivoBotCreateWithoutAssistantInput[] | JivoBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutAssistantInput | JivoBotCreateOrConnectWithoutAssistantInput[]
    createMany?: JivoBotCreateManyAssistantInputEnvelope
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateOneRequiredWithoutAssistantsNestedInput = {
    create?: XOR<ProfileCreateWithoutAssistantsInput, ProfileUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAssistantsInput
    upsert?: ProfileUpsertWithoutAssistantsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutAssistantsInput, ProfileUpdateWithoutAssistantsInput>, ProfileUncheckedUpdateWithoutAssistantsInput>
  }

  export type TelegramBotUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<TelegramBotCreateWithoutAssistantInput, TelegramBotUncheckedCreateWithoutAssistantInput> | TelegramBotCreateWithoutAssistantInput[] | TelegramBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutAssistantInput | TelegramBotCreateOrConnectWithoutAssistantInput[]
    upsert?: TelegramBotUpsertWithWhereUniqueWithoutAssistantInput | TelegramBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: TelegramBotCreateManyAssistantInputEnvelope
    set?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    disconnect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    delete?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    update?: TelegramBotUpdateWithWhereUniqueWithoutAssistantInput | TelegramBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: TelegramBotUpdateManyWithWhereWithoutAssistantInput | TelegramBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: TelegramBotScalarWhereInput | TelegramBotScalarWhereInput[]
  }

  export type TelegramUserBotUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<TelegramUserBotCreateWithoutAssistantInput, TelegramUserBotUncheckedCreateWithoutAssistantInput> | TelegramUserBotCreateWithoutAssistantInput[] | TelegramUserBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutAssistantInput | TelegramUserBotCreateOrConnectWithoutAssistantInput[]
    upsert?: TelegramUserBotUpsertWithWhereUniqueWithoutAssistantInput | TelegramUserBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: TelegramUserBotCreateManyAssistantInputEnvelope
    set?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    disconnect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    delete?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    update?: TelegramUserBotUpdateWithWhereUniqueWithoutAssistantInput | TelegramUserBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: TelegramUserBotUpdateManyWithWhereWithoutAssistantInput | TelegramUserBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: TelegramUserBotScalarWhereInput | TelegramUserBotScalarWhereInput[]
  }

  export type WhatsAppBotUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<WhatsAppBotCreateWithoutAssistantInput, WhatsAppBotUncheckedCreateWithoutAssistantInput> | WhatsAppBotCreateWithoutAssistantInput[] | WhatsAppBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutAssistantInput | WhatsAppBotCreateOrConnectWithoutAssistantInput[]
    upsert?: WhatsAppBotUpsertWithWhereUniqueWithoutAssistantInput | WhatsAppBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: WhatsAppBotCreateManyAssistantInputEnvelope
    set?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    disconnect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    delete?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    update?: WhatsAppBotUpdateWithWhereUniqueWithoutAssistantInput | WhatsAppBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: WhatsAppBotUpdateManyWithWhereWithoutAssistantInput | WhatsAppBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: WhatsAppBotScalarWhereInput | WhatsAppBotScalarWhereInput[]
  }

  export type JivoBotUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<JivoBotCreateWithoutAssistantInput, JivoBotUncheckedCreateWithoutAssistantInput> | JivoBotCreateWithoutAssistantInput[] | JivoBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutAssistantInput | JivoBotCreateOrConnectWithoutAssistantInput[]
    upsert?: JivoBotUpsertWithWhereUniqueWithoutAssistantInput | JivoBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: JivoBotCreateManyAssistantInputEnvelope
    set?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    disconnect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    delete?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    update?: JivoBotUpdateWithWhereUniqueWithoutAssistantInput | JivoBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: JivoBotUpdateManyWithWhereWithoutAssistantInput | JivoBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: JivoBotScalarWhereInput | JivoBotScalarWhereInput[]
  }

  export type TelegramBotUncheckedUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<TelegramBotCreateWithoutAssistantInput, TelegramBotUncheckedCreateWithoutAssistantInput> | TelegramBotCreateWithoutAssistantInput[] | TelegramBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramBotCreateOrConnectWithoutAssistantInput | TelegramBotCreateOrConnectWithoutAssistantInput[]
    upsert?: TelegramBotUpsertWithWhereUniqueWithoutAssistantInput | TelegramBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: TelegramBotCreateManyAssistantInputEnvelope
    set?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    disconnect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    delete?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    connect?: TelegramBotWhereUniqueInput | TelegramBotWhereUniqueInput[]
    update?: TelegramBotUpdateWithWhereUniqueWithoutAssistantInput | TelegramBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: TelegramBotUpdateManyWithWhereWithoutAssistantInput | TelegramBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: TelegramBotScalarWhereInput | TelegramBotScalarWhereInput[]
  }

  export type TelegramUserBotUncheckedUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<TelegramUserBotCreateWithoutAssistantInput, TelegramUserBotUncheckedCreateWithoutAssistantInput> | TelegramUserBotCreateWithoutAssistantInput[] | TelegramUserBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: TelegramUserBotCreateOrConnectWithoutAssistantInput | TelegramUserBotCreateOrConnectWithoutAssistantInput[]
    upsert?: TelegramUserBotUpsertWithWhereUniqueWithoutAssistantInput | TelegramUserBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: TelegramUserBotCreateManyAssistantInputEnvelope
    set?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    disconnect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    delete?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    connect?: TelegramUserBotWhereUniqueInput | TelegramUserBotWhereUniqueInput[]
    update?: TelegramUserBotUpdateWithWhereUniqueWithoutAssistantInput | TelegramUserBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: TelegramUserBotUpdateManyWithWhereWithoutAssistantInput | TelegramUserBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: TelegramUserBotScalarWhereInput | TelegramUserBotScalarWhereInput[]
  }

  export type WhatsAppBotUncheckedUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<WhatsAppBotCreateWithoutAssistantInput, WhatsAppBotUncheckedCreateWithoutAssistantInput> | WhatsAppBotCreateWithoutAssistantInput[] | WhatsAppBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: WhatsAppBotCreateOrConnectWithoutAssistantInput | WhatsAppBotCreateOrConnectWithoutAssistantInput[]
    upsert?: WhatsAppBotUpsertWithWhereUniqueWithoutAssistantInput | WhatsAppBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: WhatsAppBotCreateManyAssistantInputEnvelope
    set?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    disconnect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    delete?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    connect?: WhatsAppBotWhereUniqueInput | WhatsAppBotWhereUniqueInput[]
    update?: WhatsAppBotUpdateWithWhereUniqueWithoutAssistantInput | WhatsAppBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: WhatsAppBotUpdateManyWithWhereWithoutAssistantInput | WhatsAppBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: WhatsAppBotScalarWhereInput | WhatsAppBotScalarWhereInput[]
  }

  export type JivoBotUncheckedUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<JivoBotCreateWithoutAssistantInput, JivoBotUncheckedCreateWithoutAssistantInput> | JivoBotCreateWithoutAssistantInput[] | JivoBotUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: JivoBotCreateOrConnectWithoutAssistantInput | JivoBotCreateOrConnectWithoutAssistantInput[]
    upsert?: JivoBotUpsertWithWhereUniqueWithoutAssistantInput | JivoBotUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: JivoBotCreateManyAssistantInputEnvelope
    set?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    disconnect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    delete?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    connect?: JivoBotWhereUniqueInput | JivoBotWhereUniqueInput[]
    update?: JivoBotUpdateWithWhereUniqueWithoutAssistantInput | JivoBotUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: JivoBotUpdateManyWithWhereWithoutAssistantInput | JivoBotUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: JivoBotScalarWhereInput | JivoBotScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutTelegramBotsInput = {
    create?: XOR<ProfileCreateWithoutTelegramBotsInput, ProfileUncheckedCreateWithoutTelegramBotsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTelegramBotsInput
    connect?: ProfileWhereUniqueInput
  }

  export type AssistantCreateNestedOneWithoutTelegramBotsInput = {
    create?: XOR<AssistantCreateWithoutTelegramBotsInput, AssistantUncheckedCreateWithoutTelegramBotsInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutTelegramBotsInput
    connect?: AssistantWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutTelegramBotsNestedInput = {
    create?: XOR<ProfileCreateWithoutTelegramBotsInput, ProfileUncheckedCreateWithoutTelegramBotsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTelegramBotsInput
    upsert?: ProfileUpsertWithoutTelegramBotsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTelegramBotsInput, ProfileUpdateWithoutTelegramBotsInput>, ProfileUncheckedUpdateWithoutTelegramBotsInput>
  }

  export type AssistantUpdateOneWithoutTelegramBotsNestedInput = {
    create?: XOR<AssistantCreateWithoutTelegramBotsInput, AssistantUncheckedCreateWithoutTelegramBotsInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutTelegramBotsInput
    upsert?: AssistantUpsertWithoutTelegramBotsInput
    disconnect?: AssistantWhereInput | boolean
    delete?: AssistantWhereInput | boolean
    connect?: AssistantWhereUniqueInput
    update?: XOR<XOR<AssistantUpdateToOneWithWhereWithoutTelegramBotsInput, AssistantUpdateWithoutTelegramBotsInput>, AssistantUncheckedUpdateWithoutTelegramBotsInput>
  }

  export type ProfileCreateNestedOneWithoutTelegramUserBotsInput = {
    create?: XOR<ProfileCreateWithoutTelegramUserBotsInput, ProfileUncheckedCreateWithoutTelegramUserBotsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTelegramUserBotsInput
    connect?: ProfileWhereUniqueInput
  }

  export type AssistantCreateNestedOneWithoutTelegramUserBotsInput = {
    create?: XOR<AssistantCreateWithoutTelegramUserBotsInput, AssistantUncheckedCreateWithoutTelegramUserBotsInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutTelegramUserBotsInput
    connect?: AssistantWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutTelegramUserBotsNestedInput = {
    create?: XOR<ProfileCreateWithoutTelegramUserBotsInput, ProfileUncheckedCreateWithoutTelegramUserBotsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTelegramUserBotsInput
    upsert?: ProfileUpsertWithoutTelegramUserBotsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTelegramUserBotsInput, ProfileUpdateWithoutTelegramUserBotsInput>, ProfileUncheckedUpdateWithoutTelegramUserBotsInput>
  }

  export type AssistantUpdateOneRequiredWithoutTelegramUserBotsNestedInput = {
    create?: XOR<AssistantCreateWithoutTelegramUserBotsInput, AssistantUncheckedCreateWithoutTelegramUserBotsInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutTelegramUserBotsInput
    upsert?: AssistantUpsertWithoutTelegramUserBotsInput
    connect?: AssistantWhereUniqueInput
    update?: XOR<XOR<AssistantUpdateToOneWithWhereWithoutTelegramUserBotsInput, AssistantUpdateWithoutTelegramUserBotsInput>, AssistantUncheckedUpdateWithoutTelegramUserBotsInput>
  }

  export type ProfileCreateNestedOneWithoutWhatsAppBotInput = {
    create?: XOR<ProfileCreateWithoutWhatsAppBotInput, ProfileUncheckedCreateWithoutWhatsAppBotInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutWhatsAppBotInput
    connect?: ProfileWhereUniqueInput
  }

  export type AssistantCreateNestedOneWithoutWhatsAppBotInput = {
    create?: XOR<AssistantCreateWithoutWhatsAppBotInput, AssistantUncheckedCreateWithoutWhatsAppBotInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutWhatsAppBotInput
    connect?: AssistantWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutWhatsAppBotNestedInput = {
    create?: XOR<ProfileCreateWithoutWhatsAppBotInput, ProfileUncheckedCreateWithoutWhatsAppBotInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutWhatsAppBotInput
    upsert?: ProfileUpsertWithoutWhatsAppBotInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutWhatsAppBotInput, ProfileUpdateWithoutWhatsAppBotInput>, ProfileUncheckedUpdateWithoutWhatsAppBotInput>
  }

  export type AssistantUpdateOneRequiredWithoutWhatsAppBotNestedInput = {
    create?: XOR<AssistantCreateWithoutWhatsAppBotInput, AssistantUncheckedCreateWithoutWhatsAppBotInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutWhatsAppBotInput
    upsert?: AssistantUpsertWithoutWhatsAppBotInput
    connect?: AssistantWhereUniqueInput
    update?: XOR<XOR<AssistantUpdateToOneWithWhereWithoutWhatsAppBotInput, AssistantUpdateWithoutWhatsAppBotInput>, AssistantUncheckedUpdateWithoutWhatsAppBotInput>
  }

  export type ProfileCreateNestedOneWithoutJivoBotInput = {
    create?: XOR<ProfileCreateWithoutJivoBotInput, ProfileUncheckedCreateWithoutJivoBotInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutJivoBotInput
    connect?: ProfileWhereUniqueInput
  }

  export type AssistantCreateNestedOneWithoutJivoBotInput = {
    create?: XOR<AssistantCreateWithoutJivoBotInput, AssistantUncheckedCreateWithoutJivoBotInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutJivoBotInput
    connect?: AssistantWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutJivoBotNestedInput = {
    create?: XOR<ProfileCreateWithoutJivoBotInput, ProfileUncheckedCreateWithoutJivoBotInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutJivoBotInput
    upsert?: ProfileUpsertWithoutJivoBotInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutJivoBotInput, ProfileUpdateWithoutJivoBotInput>, ProfileUncheckedUpdateWithoutJivoBotInput>
  }

  export type AssistantUpdateOneRequiredWithoutJivoBotNestedInput = {
    create?: XOR<AssistantCreateWithoutJivoBotInput, AssistantUncheckedCreateWithoutJivoBotInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutJivoBotInput
    upsert?: AssistantUpsertWithoutJivoBotInput
    connect?: AssistantWhereUniqueInput
    update?: XOR<XOR<AssistantUpdateToOneWithWhereWithoutJivoBotInput, AssistantUpdateWithoutJivoBotInput>, AssistantUncheckedUpdateWithoutJivoBotInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AssistantCreateWithoutProfileInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramBots?: TelegramBotCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type AssistantCreateOrConnectWithoutProfileInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutProfileInput, AssistantUncheckedCreateWithoutProfileInput>
  }

  export type AssistantCreateManyProfileInputEnvelope = {
    data: AssistantCreateManyProfileInput | AssistantCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type TelegramBotCreateWithoutProfileInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assistant?: AssistantCreateNestedOneWithoutTelegramBotsInput
  }

  export type TelegramBotUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    assistantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramBotCreateOrConnectWithoutProfileInput = {
    where: TelegramBotWhereUniqueInput
    create: XOR<TelegramBotCreateWithoutProfileInput, TelegramBotUncheckedCreateWithoutProfileInput>
  }

  export type TelegramBotCreateManyProfileInputEnvelope = {
    data: TelegramBotCreateManyProfileInput | TelegramBotCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type TelegramUserBotCreateWithoutProfileInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assistant: AssistantCreateNestedOneWithoutTelegramUserBotsInput
  }

  export type TelegramUserBotUncheckedCreateWithoutProfileInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserBotCreateOrConnectWithoutProfileInput = {
    where: TelegramUserBotWhereUniqueInput
    create: XOR<TelegramUserBotCreateWithoutProfileInput, TelegramUserBotUncheckedCreateWithoutProfileInput>
  }

  export type TelegramUserBotCreateManyProfileInputEnvelope = {
    data: TelegramUserBotCreateManyProfileInput | TelegramUserBotCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppBotCreateWithoutProfileInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assistant: AssistantCreateNestedOneWithoutWhatsAppBotInput
  }

  export type WhatsAppBotUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppBotCreateOrConnectWithoutProfileInput = {
    where: WhatsAppBotWhereUniqueInput
    create: XOR<WhatsAppBotCreateWithoutProfileInput, WhatsAppBotUncheckedCreateWithoutProfileInput>
  }

  export type WhatsAppBotCreateManyProfileInputEnvelope = {
    data: WhatsAppBotCreateManyProfileInput | WhatsAppBotCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type JivoBotCreateWithoutProfileInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    provider_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assistant: AssistantCreateNestedOneWithoutJivoBotInput
  }

  export type JivoBotUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    provider_id: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JivoBotCreateOrConnectWithoutProfileInput = {
    where: JivoBotWhereUniqueInput
    create: XOR<JivoBotCreateWithoutProfileInput, JivoBotUncheckedCreateWithoutProfileInput>
  }

  export type JivoBotCreateManyProfileInputEnvelope = {
    data: JivoBotCreateManyProfileInput | JivoBotCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type AssistantUpsertWithWhereUniqueWithoutProfileInput = {
    where: AssistantWhereUniqueInput
    update: XOR<AssistantUpdateWithoutProfileInput, AssistantUncheckedUpdateWithoutProfileInput>
    create: XOR<AssistantCreateWithoutProfileInput, AssistantUncheckedCreateWithoutProfileInput>
  }

  export type AssistantUpdateWithWhereUniqueWithoutProfileInput = {
    where: AssistantWhereUniqueInput
    data: XOR<AssistantUpdateWithoutProfileInput, AssistantUncheckedUpdateWithoutProfileInput>
  }

  export type AssistantUpdateManyWithWhereWithoutProfileInput = {
    where: AssistantScalarWhereInput
    data: XOR<AssistantUpdateManyMutationInput, AssistantUncheckedUpdateManyWithoutProfileInput>
  }

  export type AssistantScalarWhereInput = {
    AND?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
    OR?: AssistantScalarWhereInput[]
    NOT?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
    id?: StringFilter<"Assistant"> | string
    name?: StringFilter<"Assistant"> | string
    settings?: StringFilter<"Assistant"> | string
    use_count?: IntFilter<"Assistant"> | number
    comment?: StringFilter<"Assistant"> | string
    token?: StringFilter<"Assistant"> | string
    imageUrl?: StringFilter<"Assistant"> | string
    temperature?: FloatFilter<"Assistant"> | number
    profileId?: StringFilter<"Assistant"> | string
    createdAt?: DateTimeFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeFilter<"Assistant"> | Date | string
  }

  export type TelegramBotUpsertWithWhereUniqueWithoutProfileInput = {
    where: TelegramBotWhereUniqueInput
    update: XOR<TelegramBotUpdateWithoutProfileInput, TelegramBotUncheckedUpdateWithoutProfileInput>
    create: XOR<TelegramBotCreateWithoutProfileInput, TelegramBotUncheckedCreateWithoutProfileInput>
  }

  export type TelegramBotUpdateWithWhereUniqueWithoutProfileInput = {
    where: TelegramBotWhereUniqueInput
    data: XOR<TelegramBotUpdateWithoutProfileInput, TelegramBotUncheckedUpdateWithoutProfileInput>
  }

  export type TelegramBotUpdateManyWithWhereWithoutProfileInput = {
    where: TelegramBotScalarWhereInput
    data: XOR<TelegramBotUpdateManyMutationInput, TelegramBotUncheckedUpdateManyWithoutProfileInput>
  }

  export type TelegramBotScalarWhereInput = {
    AND?: TelegramBotScalarWhereInput | TelegramBotScalarWhereInput[]
    OR?: TelegramBotScalarWhereInput[]
    NOT?: TelegramBotScalarWhereInput | TelegramBotScalarWhereInput[]
    id?: StringFilter<"TelegramBot"> | string
    name?: StringFilter<"TelegramBot"> | string
    telegram_id?: StringFilter<"TelegramBot"> | string
    imageUrl?: StringFilter<"TelegramBot"> | string
    useCount?: IntFilter<"TelegramBot"> | number
    token?: StringFilter<"TelegramBot"> | string
    profileId?: StringFilter<"TelegramBot"> | string
    assistantId?: StringNullableFilter<"TelegramBot"> | string | null
    createdAt?: DateTimeFilter<"TelegramBot"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramBot"> | Date | string
  }

  export type TelegramUserBotUpsertWithWhereUniqueWithoutProfileInput = {
    where: TelegramUserBotWhereUniqueInput
    update: XOR<TelegramUserBotUpdateWithoutProfileInput, TelegramUserBotUncheckedUpdateWithoutProfileInput>
    create: XOR<TelegramUserBotCreateWithoutProfileInput, TelegramUserBotUncheckedCreateWithoutProfileInput>
  }

  export type TelegramUserBotUpdateWithWhereUniqueWithoutProfileInput = {
    where: TelegramUserBotWhereUniqueInput
    data: XOR<TelegramUserBotUpdateWithoutProfileInput, TelegramUserBotUncheckedUpdateWithoutProfileInput>
  }

  export type TelegramUserBotUpdateManyWithWhereWithoutProfileInput = {
    where: TelegramUserBotScalarWhereInput
    data: XOR<TelegramUserBotUpdateManyMutationInput, TelegramUserBotUncheckedUpdateManyWithoutProfileInput>
  }

  export type TelegramUserBotScalarWhereInput = {
    AND?: TelegramUserBotScalarWhereInput | TelegramUserBotScalarWhereInput[]
    OR?: TelegramUserBotScalarWhereInput[]
    NOT?: TelegramUserBotScalarWhereInput | TelegramUserBotScalarWhereInput[]
    id?: StringFilter<"TelegramUserBot"> | string
    firstName?: StringFilter<"TelegramUserBot"> | string
    lastName?: StringFilter<"TelegramUserBot"> | string
    username?: StringFilter<"TelegramUserBot"> | string
    imageUrl?: StringFilter<"TelegramUserBot"> | string
    useCount?: IntFilter<"TelegramUserBot"> | number
    phone?: StringFilter<"TelegramUserBot"> | string
    api_id?: StringFilter<"TelegramUserBot"> | string
    api_hash?: StringFilter<"TelegramUserBot"> | string
    profileId?: StringFilter<"TelegramUserBot"> | string
    assistantId?: StringFilter<"TelegramUserBot"> | string
    createdAt?: DateTimeFilter<"TelegramUserBot"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramUserBot"> | Date | string
  }

  export type WhatsAppBotUpsertWithWhereUniqueWithoutProfileInput = {
    where: WhatsAppBotWhereUniqueInput
    update: XOR<WhatsAppBotUpdateWithoutProfileInput, WhatsAppBotUncheckedUpdateWithoutProfileInput>
    create: XOR<WhatsAppBotCreateWithoutProfileInput, WhatsAppBotUncheckedCreateWithoutProfileInput>
  }

  export type WhatsAppBotUpdateWithWhereUniqueWithoutProfileInput = {
    where: WhatsAppBotWhereUniqueInput
    data: XOR<WhatsAppBotUpdateWithoutProfileInput, WhatsAppBotUncheckedUpdateWithoutProfileInput>
  }

  export type WhatsAppBotUpdateManyWithWhereWithoutProfileInput = {
    where: WhatsAppBotScalarWhereInput
    data: XOR<WhatsAppBotUpdateManyMutationInput, WhatsAppBotUncheckedUpdateManyWithoutProfileInput>
  }

  export type WhatsAppBotScalarWhereInput = {
    AND?: WhatsAppBotScalarWhereInput | WhatsAppBotScalarWhereInput[]
    OR?: WhatsAppBotScalarWhereInput[]
    NOT?: WhatsAppBotScalarWhereInput | WhatsAppBotScalarWhereInput[]
    id?: StringFilter<"WhatsAppBot"> | string
    name?: StringFilter<"WhatsAppBot"> | string
    settings?: StringFilter<"WhatsAppBot"> | string
    imageUrl?: StringFilter<"WhatsAppBot"> | string
    useCount?: IntFilter<"WhatsAppBot"> | number
    fullName?: StringFilter<"WhatsAppBot"> | string
    phone?: StringFilter<"WhatsAppBot"> | string
    IdInstance?: StringFilter<"WhatsAppBot"> | string
    ApiTokenInstance?: StringFilter<"WhatsAppBot"> | string
    profileId?: StringFilter<"WhatsAppBot"> | string
    assistantId?: StringFilter<"WhatsAppBot"> | string
    createdAt?: DateTimeFilter<"WhatsAppBot"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppBot"> | Date | string
  }

  export type JivoBotUpsertWithWhereUniqueWithoutProfileInput = {
    where: JivoBotWhereUniqueInput
    update: XOR<JivoBotUpdateWithoutProfileInput, JivoBotUncheckedUpdateWithoutProfileInput>
    create: XOR<JivoBotCreateWithoutProfileInput, JivoBotUncheckedCreateWithoutProfileInput>
  }

  export type JivoBotUpdateWithWhereUniqueWithoutProfileInput = {
    where: JivoBotWhereUniqueInput
    data: XOR<JivoBotUpdateWithoutProfileInput, JivoBotUncheckedUpdateWithoutProfileInput>
  }

  export type JivoBotUpdateManyWithWhereWithoutProfileInput = {
    where: JivoBotScalarWhereInput
    data: XOR<JivoBotUpdateManyMutationInput, JivoBotUncheckedUpdateManyWithoutProfileInput>
  }

  export type JivoBotScalarWhereInput = {
    AND?: JivoBotScalarWhereInput | JivoBotScalarWhereInput[]
    OR?: JivoBotScalarWhereInput[]
    NOT?: JivoBotScalarWhereInput | JivoBotScalarWhereInput[]
    id?: StringFilter<"JivoBot"> | string
    name?: StringFilter<"JivoBot"> | string
    settings?: StringFilter<"JivoBot"> | string
    imageUrl?: StringFilter<"JivoBot"> | string
    profileId?: StringFilter<"JivoBot"> | string
    useCount?: IntFilter<"JivoBot"> | number
    provider_id?: StringFilter<"JivoBot"> | string
    assistantId?: StringFilter<"JivoBot"> | string
    createdAt?: DateTimeFilter<"JivoBot"> | Date | string
    updatedAt?: DateTimeFilter<"JivoBot"> | Date | string
  }

  export type ProfileCreateWithoutAssistantsInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    telegramBots?: TelegramBotCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutAssistantsInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutAssistantsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAssistantsInput, ProfileUncheckedCreateWithoutAssistantsInput>
  }

  export type TelegramBotCreateWithoutAssistantInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTelegramBotsInput
  }

  export type TelegramBotUncheckedCreateWithoutAssistantInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramBotCreateOrConnectWithoutAssistantInput = {
    where: TelegramBotWhereUniqueInput
    create: XOR<TelegramBotCreateWithoutAssistantInput, TelegramBotUncheckedCreateWithoutAssistantInput>
  }

  export type TelegramBotCreateManyAssistantInputEnvelope = {
    data: TelegramBotCreateManyAssistantInput | TelegramBotCreateManyAssistantInput[]
    skipDuplicates?: boolean
  }

  export type TelegramUserBotCreateWithoutAssistantInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTelegramUserBotsInput
  }

  export type TelegramUserBotUncheckedCreateWithoutAssistantInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserBotCreateOrConnectWithoutAssistantInput = {
    where: TelegramUserBotWhereUniqueInput
    create: XOR<TelegramUserBotCreateWithoutAssistantInput, TelegramUserBotUncheckedCreateWithoutAssistantInput>
  }

  export type TelegramUserBotCreateManyAssistantInputEnvelope = {
    data: TelegramUserBotCreateManyAssistantInput | TelegramUserBotCreateManyAssistantInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppBotCreateWithoutAssistantInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutWhatsAppBotInput
  }

  export type WhatsAppBotUncheckedCreateWithoutAssistantInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppBotCreateOrConnectWithoutAssistantInput = {
    where: WhatsAppBotWhereUniqueInput
    create: XOR<WhatsAppBotCreateWithoutAssistantInput, WhatsAppBotUncheckedCreateWithoutAssistantInput>
  }

  export type WhatsAppBotCreateManyAssistantInputEnvelope = {
    data: WhatsAppBotCreateManyAssistantInput | WhatsAppBotCreateManyAssistantInput[]
    skipDuplicates?: boolean
  }

  export type JivoBotCreateWithoutAssistantInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    provider_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutJivoBotInput
  }

  export type JivoBotUncheckedCreateWithoutAssistantInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    profileId: string
    useCount?: number
    provider_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JivoBotCreateOrConnectWithoutAssistantInput = {
    where: JivoBotWhereUniqueInput
    create: XOR<JivoBotCreateWithoutAssistantInput, JivoBotUncheckedCreateWithoutAssistantInput>
  }

  export type JivoBotCreateManyAssistantInputEnvelope = {
    data: JivoBotCreateManyAssistantInput | JivoBotCreateManyAssistantInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutAssistantsInput = {
    update: XOR<ProfileUpdateWithoutAssistantsInput, ProfileUncheckedUpdateWithoutAssistantsInput>
    create: XOR<ProfileCreateWithoutAssistantsInput, ProfileUncheckedCreateWithoutAssistantsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutAssistantsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutAssistantsInput, ProfileUncheckedUpdateWithoutAssistantsInput>
  }

  export type ProfileUpdateWithoutAssistantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAssistantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type TelegramBotUpsertWithWhereUniqueWithoutAssistantInput = {
    where: TelegramBotWhereUniqueInput
    update: XOR<TelegramBotUpdateWithoutAssistantInput, TelegramBotUncheckedUpdateWithoutAssistantInput>
    create: XOR<TelegramBotCreateWithoutAssistantInput, TelegramBotUncheckedCreateWithoutAssistantInput>
  }

  export type TelegramBotUpdateWithWhereUniqueWithoutAssistantInput = {
    where: TelegramBotWhereUniqueInput
    data: XOR<TelegramBotUpdateWithoutAssistantInput, TelegramBotUncheckedUpdateWithoutAssistantInput>
  }

  export type TelegramBotUpdateManyWithWhereWithoutAssistantInput = {
    where: TelegramBotScalarWhereInput
    data: XOR<TelegramBotUpdateManyMutationInput, TelegramBotUncheckedUpdateManyWithoutAssistantInput>
  }

  export type TelegramUserBotUpsertWithWhereUniqueWithoutAssistantInput = {
    where: TelegramUserBotWhereUniqueInput
    update: XOR<TelegramUserBotUpdateWithoutAssistantInput, TelegramUserBotUncheckedUpdateWithoutAssistantInput>
    create: XOR<TelegramUserBotCreateWithoutAssistantInput, TelegramUserBotUncheckedCreateWithoutAssistantInput>
  }

  export type TelegramUserBotUpdateWithWhereUniqueWithoutAssistantInput = {
    where: TelegramUserBotWhereUniqueInput
    data: XOR<TelegramUserBotUpdateWithoutAssistantInput, TelegramUserBotUncheckedUpdateWithoutAssistantInput>
  }

  export type TelegramUserBotUpdateManyWithWhereWithoutAssistantInput = {
    where: TelegramUserBotScalarWhereInput
    data: XOR<TelegramUserBotUpdateManyMutationInput, TelegramUserBotUncheckedUpdateManyWithoutAssistantInput>
  }

  export type WhatsAppBotUpsertWithWhereUniqueWithoutAssistantInput = {
    where: WhatsAppBotWhereUniqueInput
    update: XOR<WhatsAppBotUpdateWithoutAssistantInput, WhatsAppBotUncheckedUpdateWithoutAssistantInput>
    create: XOR<WhatsAppBotCreateWithoutAssistantInput, WhatsAppBotUncheckedCreateWithoutAssistantInput>
  }

  export type WhatsAppBotUpdateWithWhereUniqueWithoutAssistantInput = {
    where: WhatsAppBotWhereUniqueInput
    data: XOR<WhatsAppBotUpdateWithoutAssistantInput, WhatsAppBotUncheckedUpdateWithoutAssistantInput>
  }

  export type WhatsAppBotUpdateManyWithWhereWithoutAssistantInput = {
    where: WhatsAppBotScalarWhereInput
    data: XOR<WhatsAppBotUpdateManyMutationInput, WhatsAppBotUncheckedUpdateManyWithoutAssistantInput>
  }

  export type JivoBotUpsertWithWhereUniqueWithoutAssistantInput = {
    where: JivoBotWhereUniqueInput
    update: XOR<JivoBotUpdateWithoutAssistantInput, JivoBotUncheckedUpdateWithoutAssistantInput>
    create: XOR<JivoBotCreateWithoutAssistantInput, JivoBotUncheckedCreateWithoutAssistantInput>
  }

  export type JivoBotUpdateWithWhereUniqueWithoutAssistantInput = {
    where: JivoBotWhereUniqueInput
    data: XOR<JivoBotUpdateWithoutAssistantInput, JivoBotUncheckedUpdateWithoutAssistantInput>
  }

  export type JivoBotUpdateManyWithWhereWithoutAssistantInput = {
    where: JivoBotScalarWhereInput
    data: XOR<JivoBotUpdateManyMutationInput, JivoBotUncheckedUpdateManyWithoutAssistantInput>
  }

  export type ProfileCreateWithoutTelegramBotsInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTelegramBotsInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantUncheckedCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTelegramBotsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTelegramBotsInput, ProfileUncheckedCreateWithoutTelegramBotsInput>
  }

  export type AssistantCreateWithoutTelegramBotsInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutAssistantsInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUncheckedCreateWithoutTelegramBotsInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type AssistantCreateOrConnectWithoutTelegramBotsInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutTelegramBotsInput, AssistantUncheckedCreateWithoutTelegramBotsInput>
  }

  export type ProfileUpsertWithoutTelegramBotsInput = {
    update: XOR<ProfileUpdateWithoutTelegramBotsInput, ProfileUncheckedUpdateWithoutTelegramBotsInput>
    create: XOR<ProfileCreateWithoutTelegramBotsInput, ProfileUncheckedCreateWithoutTelegramBotsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTelegramBotsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTelegramBotsInput, ProfileUncheckedUpdateWithoutTelegramBotsInput>
  }

  export type ProfileUpdateWithoutTelegramBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTelegramBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUncheckedUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AssistantUpsertWithoutTelegramBotsInput = {
    update: XOR<AssistantUpdateWithoutTelegramBotsInput, AssistantUncheckedUpdateWithoutTelegramBotsInput>
    create: XOR<AssistantCreateWithoutTelegramBotsInput, AssistantUncheckedCreateWithoutTelegramBotsInput>
    where?: AssistantWhereInput
  }

  export type AssistantUpdateToOneWithWhereWithoutTelegramBotsInput = {
    where?: AssistantWhereInput
    data: XOR<AssistantUpdateWithoutTelegramBotsInput, AssistantUncheckedUpdateWithoutTelegramBotsInput>
  }

  export type AssistantUpdateWithoutTelegramBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutAssistantsNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutTelegramBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type ProfileCreateWithoutTelegramUserBotsInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTelegramUserBotsInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantUncheckedCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTelegramUserBotsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTelegramUserBotsInput, ProfileUncheckedCreateWithoutTelegramUserBotsInput>
  }

  export type AssistantCreateWithoutTelegramUserBotsInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutAssistantsInput
    telegramBots?: TelegramBotCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUncheckedCreateWithoutTelegramUserBotsInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type AssistantCreateOrConnectWithoutTelegramUserBotsInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutTelegramUserBotsInput, AssistantUncheckedCreateWithoutTelegramUserBotsInput>
  }

  export type ProfileUpsertWithoutTelegramUserBotsInput = {
    update: XOR<ProfileUpdateWithoutTelegramUserBotsInput, ProfileUncheckedUpdateWithoutTelegramUserBotsInput>
    create: XOR<ProfileCreateWithoutTelegramUserBotsInput, ProfileUncheckedCreateWithoutTelegramUserBotsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTelegramUserBotsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTelegramUserBotsInput, ProfileUncheckedUpdateWithoutTelegramUserBotsInput>
  }

  export type ProfileUpdateWithoutTelegramUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTelegramUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUncheckedUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AssistantUpsertWithoutTelegramUserBotsInput = {
    update: XOR<AssistantUpdateWithoutTelegramUserBotsInput, AssistantUncheckedUpdateWithoutTelegramUserBotsInput>
    create: XOR<AssistantCreateWithoutTelegramUserBotsInput, AssistantUncheckedCreateWithoutTelegramUserBotsInput>
    where?: AssistantWhereInput
  }

  export type AssistantUpdateToOneWithWhereWithoutTelegramUserBotsInput = {
    where?: AssistantWhereInput
    data: XOR<AssistantUpdateWithoutTelegramUserBotsInput, AssistantUncheckedUpdateWithoutTelegramUserBotsInput>
  }

  export type AssistantUpdateWithoutTelegramUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutAssistantsNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutTelegramUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type ProfileCreateWithoutWhatsAppBotInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutWhatsAppBotInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantUncheckedCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutProfileInput
    JivoBot?: JivoBotUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutWhatsAppBotInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutWhatsAppBotInput, ProfileUncheckedCreateWithoutWhatsAppBotInput>
  }

  export type AssistantCreateWithoutWhatsAppBotInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutAssistantsInput
    telegramBots?: TelegramBotCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUncheckedCreateWithoutWhatsAppBotInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutAssistantInput
    jivoBot?: JivoBotUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type AssistantCreateOrConnectWithoutWhatsAppBotInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutWhatsAppBotInput, AssistantUncheckedCreateWithoutWhatsAppBotInput>
  }

  export type ProfileUpsertWithoutWhatsAppBotInput = {
    update: XOR<ProfileUpdateWithoutWhatsAppBotInput, ProfileUncheckedUpdateWithoutWhatsAppBotInput>
    create: XOR<ProfileCreateWithoutWhatsAppBotInput, ProfileUncheckedCreateWithoutWhatsAppBotInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutWhatsAppBotInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutWhatsAppBotInput, ProfileUncheckedUpdateWithoutWhatsAppBotInput>
  }

  export type ProfileUpdateWithoutWhatsAppBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutWhatsAppBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUncheckedUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutProfileNestedInput
    JivoBot?: JivoBotUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AssistantUpsertWithoutWhatsAppBotInput = {
    update: XOR<AssistantUpdateWithoutWhatsAppBotInput, AssistantUncheckedUpdateWithoutWhatsAppBotInput>
    create: XOR<AssistantCreateWithoutWhatsAppBotInput, AssistantUncheckedCreateWithoutWhatsAppBotInput>
    where?: AssistantWhereInput
  }

  export type AssistantUpdateToOneWithWhereWithoutWhatsAppBotInput = {
    where?: AssistantWhereInput
    data: XOR<AssistantUpdateWithoutWhatsAppBotInput, AssistantUncheckedUpdateWithoutWhatsAppBotInput>
  }

  export type AssistantUpdateWithoutWhatsAppBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutAssistantsNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutWhatsAppBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type ProfileCreateWithoutJivoBotInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutJivoBotInput = {
    id?: string
    userId: string
    name: string
    imageUrl: string
    login?: string | null
    password?: string | null
    email?: string | null
    token?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expires?: Date | string
    assistants?: AssistantUncheckedCreateNestedManyWithoutProfileInput
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutProfileInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutProfileInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutJivoBotInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutJivoBotInput, ProfileUncheckedCreateWithoutJivoBotInput>
  }

  export type AssistantCreateWithoutJivoBotInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutAssistantsInput
    telegramBots?: TelegramBotCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotCreateNestedManyWithoutAssistantInput
  }

  export type AssistantUncheckedCreateWithoutJivoBotInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    telegramBots?: TelegramBotUncheckedCreateNestedManyWithoutAssistantInput
    telegramUserBots?: TelegramUserBotUncheckedCreateNestedManyWithoutAssistantInput
    whatsAppBot?: WhatsAppBotUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type AssistantCreateOrConnectWithoutJivoBotInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutJivoBotInput, AssistantUncheckedCreateWithoutJivoBotInput>
  }

  export type ProfileUpsertWithoutJivoBotInput = {
    update: XOR<ProfileUpdateWithoutJivoBotInput, ProfileUncheckedUpdateWithoutJivoBotInput>
    create: XOR<ProfileCreateWithoutJivoBotInput, ProfileUncheckedCreateWithoutJivoBotInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutJivoBotInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutJivoBotInput, ProfileUncheckedUpdateWithoutJivoBotInput>
  }

  export type ProfileUpdateWithoutJivoBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutJivoBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    login?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    assistants?: AssistantUncheckedUpdateManyWithoutProfileNestedInput
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutProfileNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutProfileNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AssistantUpsertWithoutJivoBotInput = {
    update: XOR<AssistantUpdateWithoutJivoBotInput, AssistantUncheckedUpdateWithoutJivoBotInput>
    create: XOR<AssistantCreateWithoutJivoBotInput, AssistantUncheckedCreateWithoutJivoBotInput>
    where?: AssistantWhereInput
  }

  export type AssistantUpdateToOneWithWhereWithoutJivoBotInput = {
    where?: AssistantWhereInput
    data: XOR<AssistantUpdateWithoutJivoBotInput, AssistantUncheckedUpdateWithoutJivoBotInput>
  }

  export type AssistantUpdateWithoutJivoBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutAssistantsNestedInput
    telegramBots?: TelegramBotUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutJivoBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantCreateManyProfileInput = {
    id?: string
    name: string
    settings: string
    use_count?: number
    comment: string
    token?: string
    imageUrl: string
    temperature?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramBotCreateManyProfileInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    assistantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserBotCreateManyProfileInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppBotCreateManyProfileInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JivoBotCreateManyProfileInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    provider_id: string
    assistantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssistantUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telegramBots?: TelegramBotUncheckedUpdateManyWithoutAssistantNestedInput
    telegramUserBots?: TelegramUserBotUncheckedUpdateManyWithoutAssistantNestedInput
    whatsAppBot?: WhatsAppBotUncheckedUpdateManyWithoutAssistantNestedInput
    jivoBot?: JivoBotUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type AssistantUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    use_count?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant?: AssistantUpdateOneWithoutTelegramBotsNestedInput
  }

  export type TelegramBotUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant?: AssistantUpdateOneRequiredWithoutTelegramUserBotsNestedInput
  }

  export type TelegramUserBotUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant?: AssistantUpdateOneRequiredWithoutWhatsAppBotNestedInput
  }

  export type WhatsAppBotUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant?: AssistantUpdateOneRequiredWithoutJivoBotNestedInput
  }

  export type JivoBotUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotCreateManyAssistantInput = {
    id?: string
    name: string
    telegram_id: string
    imageUrl: string
    useCount?: number
    token: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserBotCreateManyAssistantInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    imageUrl: string
    useCount?: number
    phone: string
    api_id: string
    api_hash: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppBotCreateManyAssistantInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    useCount?: number
    fullName: string
    phone: string
    IdInstance: string
    ApiTokenInstance: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JivoBotCreateManyAssistantInput = {
    id?: string
    name: string
    settings: string
    imageUrl: string
    profileId: string
    useCount?: number
    provider_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramBotUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTelegramBotsNestedInput
  }

  export type TelegramBotUncheckedUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramBotUncheckedUpdateManyWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegram_id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTelegramUserBotsNestedInput
  }

  export type TelegramUserBotUncheckedUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserBotUncheckedUpdateManyWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    api_id?: StringFieldUpdateOperationsInput | string
    api_hash?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutWhatsAppBotNestedInput
  }

  export type WhatsAppBotUncheckedUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBotUncheckedUpdateManyWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    IdInstance?: StringFieldUpdateOperationsInput | string
    ApiTokenInstance?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutJivoBotNestedInput
  }

  export type JivoBotUncheckedUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JivoBotUncheckedUpdateManyWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    settings?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    useCount?: IntFieldUpdateOperationsInput | number
    provider_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssistantCountOutputTypeDefaultArgs instead
     */
    export type AssistantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssistantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssistantDefaultArgs instead
     */
    export type AssistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssistantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TelegramBotDefaultArgs instead
     */
    export type TelegramBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TelegramBotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TelegramUserBotDefaultArgs instead
     */
    export type TelegramUserBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TelegramUserBotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhatsAppBotDefaultArgs instead
     */
    export type WhatsAppBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhatsAppBotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JivoBotDefaultArgs instead
     */
    export type JivoBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JivoBotDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}